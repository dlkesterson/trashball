This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitattributes
.gitignore
index.html
package.json
README.md
src/App.tsx
src/core/GameState.ts
src/core/ScrapUnlocks.ts
src/index.css
src/main.tsx
src/orb/OrbScene.tsx
src/scraprun/ScrapRunOverlay.tsx
src/scraprun/ScrapRunScene.tsx
src/ui/MainMenu.tsx
src/ui/UpgradePanel.tsx
src/vite-env.d.ts
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.d.ts
vite.config.js
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Orb Ascent</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "orb-ascent",
  "version": "1.0.0",
  "description": "",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview",
    "lint": "echo \"No lint configured\""
  },
  "keywords": [],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "three": "^0.181.2",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@types/react": "^19.2.6",
    "@types/react-dom": "^19.2.3",
    "@types/three": "^0.181.0",
    "@vitejs/plugin-react": "^5.1.1",
    "typescript": "^5.9.3",
    "vite": "^7.2.4"
  }
}
</file>

<file path="src/App.tsx">
import { useState } from 'react';
import OrbScene from './orb/OrbScene';
import ScrapRunOverlay from './scraprun/ScrapRunOverlay';
import MainMenu from './ui/MainMenu';
import UpgradePanel from './ui/UpgradePanel';
import { useGameStore } from './core/GameState';

export default function App() {
  const scrapRunActive = useGameStore((s) => s.scrapRunActive);
  const [isHolding, setIsHolding] = useState(false);

  const enableHold = () => setIsHolding(true);
  const disableHold = () => setIsHolding(false);

  return (
    <div
      className="relative w-full h-screen overflow-hidden select-none bg-gradient-to-b from-[#0a0f2c] to-[#05060f]"
      onMouseDown={!scrapRunActive ? enableHold : undefined}
      onMouseUp={!scrapRunActive ? disableHold : undefined}
      onMouseLeave={!scrapRunActive ? disableHold : undefined}
      onTouchStart={!scrapRunActive ? enableHold : undefined}
      onTouchEnd={!scrapRunActive ? disableHold : undefined}
    >
      {!scrapRunActive && <OrbScene isHolding={isHolding} />}

      {scrapRunActive ? (
        <ScrapRunOverlay />
      ) : (
        <>
          <MainMenu />
          <UpgradePanel />
        </>
      )}
    </div>
  );
}
</file>

<file path="src/core/GameState.ts">
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { SCRAP_UPGRADES, ScrapUpgradeId, getUpgradeCost } from './ScrapUnlocks';

export type PhysicsParams = {
  gravity: number;
  thrustForce: number;
  terminalVelocity: number;
  chargeDamping: number;
};

export type GameStore = {
  energy: number;
  totalEnergy: number;
  charge: number;
  scrap: number;
  totalScrap: number;
  lastRunTime: number;
  bestRunScore: number;
  scrapRunActive: boolean;
  prestigeLevel: number;
  cosmicEssence: number;
  physics: PhysicsParams;
  upgrades: Record<ScrapUpgradeId, number>;

  addEnergy: (n: number) => void;
  setCharge: (n: number) => void;
  addScrap: (n: number) => void;
  startScrapRun: () => void;
  endScrapRun: (score: number, collected: number) => void;
  purchaseUpgrade: (id: ScrapUpgradeId) => void;
  prestige: () => void;
};

const initialPhysics: PhysicsParams = {
  gravity: 0.5,
  thrustForce: 1.2,
  terminalVelocity: 5,
  chargeDamping: 0.95,
};

const calculateEssence = (totalEnergy: number) => Math.floor(Math.sqrt(totalEnergy / 10000));

export const useGameStore = create<GameStore>()(
  persist(
    (set) => ({
      energy: 0,
      totalEnergy: 0,
      charge: 0,
      scrap: 0,
      totalScrap: 0,
      lastRunTime: 0,
      bestRunScore: 0,
      scrapRunActive: false,
      prestigeLevel: 0,
      cosmicEssence: 0,
      physics: initialPhysics,
      upgrades: {} as Record<ScrapUpgradeId, number>,

      addEnergy: (n) =>
        set((state) => ({
          energy: state.energy + n,
          totalEnergy: state.totalEnergy + n,
        })),

      setCharge: (n) => set({ charge: Math.max(0, Math.min(1, n)) }),

      addScrap: (n) =>
        set((state) => ({
          scrap: state.scrap + n,
          totalScrap: state.totalScrap + n,
        })),

      startScrapRun: () => set({ scrapRunActive: true, lastRunTime: Date.now() }),

      endScrapRun: (score, collected) =>
        set((state) => {
          const baseScrap = Math.floor(score / 10);
          const chargeBonus = state.charge > 0.9 ? 1.5 : 1;
          const prestigeBonus = 1 + state.prestigeLevel * 0.1;
          const scrapEarned = Math.floor((baseScrap + collected) * chargeBonus * prestigeBonus);

          return {
            scrap: state.scrap + scrapEarned,
            totalScrap: state.totalScrap + scrapEarned,
            bestRunScore: Math.max(state.bestRunScore, score),
            scrapRunActive: false,
            charge: 0,
          };
        }),

      purchaseUpgrade: (id) =>
        set((state) => {
          const currentLevel = state.upgrades[id] ?? 0;
          const upgrade = SCRAP_UPGRADES[id];
          if (currentLevel >= upgrade.max) return state;

          const cost = getUpgradeCost(id, currentLevel);
          if (state.scrap < cost) return state;

          return {
            scrap: state.scrap - cost,
            upgrades: { ...state.upgrades, [id]: currentLevel + 1 },
          };
        }),

      prestige: () =>
        set((state) => ({
          energy: 0,
          scrap: 0,
          upgrades: {} as Record<ScrapUpgradeId, number>,
          prestigeLevel: state.prestigeLevel + 1,
          cosmicEssence: state.cosmicEssence + calculateEssence(state.totalEnergy),
        })),
    }),
    { name: 'orb-ascent-save' }
  )
);
</file>

<file path="src/core/ScrapUnlocks.ts">
export type ScrapUpgradeId =
  | 'resonanceTuner'
  | 'criticalSurge'
  | 'orbitalStabilization'
  | 'tractorBeam'
  | 'shieldGenerator'
  | 'afterburners'
  | 'warpCooldown'
  | 'timeDilation';

export type ScrapUpgrade = {
  id: ScrapUpgradeId;
  baseCost: number;
  scale: number;
  max: number;
  label: string;
  desc: string;
};

export type ScrapUpgradeCategory = {
  id: 'harmonic' | 'scavenger' | 'chronos';
  label: string;
  accent: string;
  upgrades: ScrapUpgrade[];
};

export const SCRAP_UPGRADE_CATEGORIES: ScrapUpgradeCategory[] = [
  {
    id: 'harmonic',
    label: 'Harmonic',
    accent: '#9b87f5',
    upgrades: [
      {
        id: 'resonanceTuner',
        baseCost: 100,
        scale: 1.8,
        max: 15,
        label: 'Resonance Tuner',
        desc: '+15% energy generation per level',
      },
      {
        id: 'criticalSurge',
        baseCost: 400,
        scale: 2,
        max: 5,
        label: 'Critical Surge',
        desc: '5% chance per level to 10x a tick while holding',
      },
      {
        id: 'orbitalStabilization',
        baseCost: 750,
        scale: 2.1,
        max: 5,
        label: 'Orbital Stabilization',
        desc: 'Reduces charge drain when released',
      },
    ],
  },
  {
    id: 'scavenger',
    label: 'Scavenger',
    accent: '#22c55e',
    upgrades: [
      {
        id: 'tractorBeam',
        baseCost: 500,
        scale: 2,
        max: 5,
        label: 'Tractor Beam',
        desc: 'Wider scrap pickup radius',
      },
      {
        id: 'shieldGenerator',
        baseCost: 900,
        scale: 2.2,
        max: 3,
        label: 'Shield Generator',
        desc: 'Ignore one hit per shield charge',
      },
      {
        id: 'afterburners',
        baseCost: 1200,
        scale: 2.3,
        max: 3,
        label: 'Afterburners',
        desc: 'Faster strafe speed',
      },
    ],
  },
  {
    id: 'chronos',
    label: 'Chronos',
    accent: '#38bdf8',
    upgrades: [
      {
        id: 'warpCooldown',
        baseCost: 1500,
        scale: 2.6,
        max: 5,
        label: 'Warp Cooldown',
        desc: '-2 min launch cooldown per level',
      },
      {
        id: 'timeDilation',
        baseCost: 2000,
        scale: 2.8,
        max: 3,
        label: 'Time Dilation',
        desc: 'Scrap Run debris moves slower',
      },
    ],
  },
];

export const SCRAP_UPGRADES: Record<ScrapUpgradeId, ScrapUpgrade> = SCRAP_UPGRADE_CATEGORIES.reduce(
  (map, category) => {
    category.upgrades.forEach((upgrade) => {
      map[upgrade.id] = upgrade;
    });
    return map;
  },
  {} as Record<ScrapUpgradeId, ScrapUpgrade>
);

export const getUpgradeCost = (id: ScrapUpgradeId, currentLevel: number): number => {
  const upgrade = SCRAP_UPGRADES[id];
  return Math.floor(upgrade.baseCost * Math.pow(upgrade.scale, currentLevel));
};
</file>

<file path="src/index.css">
:root {
  font-family: 'DM Mono', 'Fira Code', 'Segoe UI', system-ui, -apple-system, sans-serif;
  color: #f8f7ff;
  background: radial-gradient(circle at 20% 20%, #0b1027, #05070f 45%);
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  min-height: 100vh;
  background: #05070f;
  color: #f8f7ff;
}

button {
  font-family: inherit;
}

.glass {
  background: rgba(18, 20, 34, 0.8);
  border: 1px solid rgba(126, 87, 194, 0.4);
  box-shadow: 0 10px 40px rgba(108, 35, 255, 0.2);
  backdrop-filter: blur(8px);
}
</file>

<file path="src/main.tsx">
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

const rootElement = document.getElementById('root');

if (!rootElement) {
  throw new Error('Root element #root not found');
}

ReactDOM.createRoot(rootElement).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="src/orb/OrbScene.tsx">
import { useEffect, useRef } from 'react';
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { useGameStore } from '../core/GameState';

type Props = {
  isHolding: boolean;
};

const ORB_COLOR_A = 0x4a0e78;
const ORB_COLOR_B = 0x0e4a78;
const CHARGE_COLOR = 0xff00ff;

export default function OrbScene({ isHolding }: Props) {
  const mountRef = useRef<HTMLDivElement>(null);
  const addEnergy = useGameStore((s) => s.addEnergy);
  const setCharge = useGameStore((s) => s.setCharge);
  const physics = useGameStore((s) => s.physics);
  const upgrades = useGameStore((s) => s.upgrades);
  const prestigeLevel = useGameStore((s) => s.prestigeLevel);

  const stateRef = useRef({
    velocity: 0,
    charge: 0,
  });

  // Keep latest external values without recreating the scene.
  const holdRef = useRef(isHolding);
  useEffect(() => {
    holdRef.current = isHolding;
  }, [isHolding]);

  const physicsRef = useRef(physics);
  useEffect(() => {
    physicsRef.current = physics;
  }, [physics]);

  const upgradesRef = useRef(upgrades);
  useEffect(() => {
    upgradesRef.current = upgrades;
  }, [upgrades]);

  const prestigeRef = useRef(prestigeLevel);
  useEffect(() => {
    prestigeRef.current = prestigeLevel;
  }, [prestigeLevel]);

  useEffect(() => {
    if (!mountRef.current) return;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
    renderer.setClearColor(0x080812, 1);
    renderer.domElement.style.position = 'absolute';
    renderer.domElement.style.inset = '0';
    mountRef.current.appendChild(renderer.domElement);

    camera.position.z = 5;

    const orbGeometry = new THREE.SphereGeometry(1, 64, 64);
    const orbMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        chargeLevel: { value: 0 },
        color1: { value: new THREE.Color(ORB_COLOR_A) },
        color2: { value: new THREE.Color(ORB_COLOR_B) },
        chargeColor: { value: new THREE.Color(CHARGE_COLOR) },
      },
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vPosition;
        uniform float time;
        uniform float chargeLevel;

        void main() {
          vNormal = normalize(normalMatrix * normal);
          vPosition = position;

          vec3 pos = position;
          float wobble = sin(time * 2.0 + position.y * 3.0) * 0.05 * chargeLevel;
          pos += normal * wobble;

          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform float chargeLevel;
        uniform vec3 color1;
        uniform vec3 color2;
        uniform vec3 chargeColor;
        varying vec3 vNormal;
        varying vec3 vPosition;

        void main() {
          float pattern = sin(vPosition.x * 3.0 + time) *
                         cos(vPosition.y * 3.0 + time * 0.7) *
                         sin(vPosition.z * 3.0 + time * 0.5);

          vec3 baseColor = mix(color1, color2, pattern * 0.5 + 0.5);
          vec3 finalColor = mix(baseColor, chargeColor, chargeLevel * 0.7);

          float fresnel = pow(1.0 - dot(vNormal, vec3(0, 0, 1)), 2.0);
          finalColor += fresnel * chargeColor * chargeLevel * 0.5;

          float particles = step(0.95, sin(vPosition.x * 20.0 + time * 5.0) *
                                       cos(vPosition.y * 20.0 + time * 3.0));
          finalColor += particles * chargeColor * chargeLevel;

          gl_FragColor = vec4(finalColor, 1.0);
        }
      `,
    });

    const orb = new THREE.Mesh(orbGeometry, orbMaterial);
    scene.add(orb);

    const particleCount = 120;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleVelocities: { x: number; y: number; z: number }[] = [];

    for (let i = 0; i < particleCount; i++) {
      particlePositions[i * 3] = (Math.random() - 0.5) * 2;
      particlePositions[i * 3 + 1] = (Math.random() - 0.5) * 2;
      particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 2;
      particleVelocities.push({
        x: (Math.random() - 0.5) * 0.02,
        y: (Math.random() - 0.5) * 0.02,
        z: (Math.random() - 0.5) * 0.02,
      });
    }

    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));

    const particleMaterial = new THREE.PointsMaterial({
      color: CHARGE_COLOR,
      size: 0.05,
      transparent: true,
      opacity: 0,
      blending: THREE.AdditiveBlending,
    });

    const particles = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particles);

    const ambientLight = new THREE.AmbientLight(0x404040, 2);
    scene.add(ambientLight);

    const pointLight = new THREE.PointLight(CHARGE_COLOR, 0, 10);
    pointLight.position.set(0, 0, 3);
    scene.add(pointLight);

    // Post-processing: bloom for high charge glow
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      0.5,
      0.8,
      0.85
    );
    composer.addPass(bloomPass);

    const clock = new THREE.Clock();
    let animationId = 0;

    const animate = () => {
      animationId = requestAnimationFrame(animate);
      const deltaTime = clock.getDelta();
      const elapsedTime = clock.getElapsedTime();
      const localState = stateRef.current;

      const physics = physicsRef.current;
      const upgrades = upgradesRef.current;
      const prestigeLevel = prestigeRef.current;

      if (holdRef.current) {
        localState.velocity += physics.thrustForce * deltaTime;
        localState.charge = Math.min(1, localState.charge + deltaTime * 2);
      } else {
        const stabilizationBonus = (upgrades.orbitalStabilization ?? 0) * 0.02;
        const effectiveDamping = Math.max(0.7, physics.chargeDamping - stabilizationBonus);
        localState.velocity -= physics.gravity * deltaTime;
        localState.charge *= effectiveDamping;
      }

      localState.velocity = Math.max(
        -physics.terminalVelocity,
        Math.min(physics.terminalVelocity, localState.velocity)
      );

      setCharge(localState.charge);

      if (localState.charge > 0) {
        const baseGen = localState.charge * 10 * deltaTime;
        const resonanceBonus = 1 + (upgrades.resonanceTuner ?? 0) * 0.15;
        const prestigeBonus = 1 + prestigeLevel * 0.5;
        const surgeChance = Math.min(1, (upgrades.criticalSurge ?? 0) * 0.05);
        const surgeMultiplier = Math.random() < surgeChance ? 10 : 1;
        addEnergy(baseGen * resonanceBonus * prestigeBonus * surgeMultiplier);
      }

      const heartbeat = 1 + Math.sin(elapsedTime * (holdRef.current ? 2 : 1)) * 0.05;
      const rotationSpeed = 0.5 + localState.charge * 3;
      orb.rotation.y = elapsedTime * rotationSpeed;
      orb.rotation.x = Math.sin(elapsedTime * 0.3) * 0.2;
      orb.scale.setScalar(heartbeat + localState.charge * 0.2);

      orbMaterial.uniforms.time.value = elapsedTime;
      orbMaterial.uniforms.chargeLevel.value = localState.charge;
      orb.position.y = Math.sin(elapsedTime * 2) * 0.1 * (1 - localState.charge * 0.5);

      particleMaterial.opacity = localState.charge * 0.8;
      const positions = particleGeometry.attributes.position.array as Float32Array;

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] += particleVelocities[i].x * (1 + localState.charge * 5);
        positions[i * 3 + 1] += particleVelocities[i].y * (1 + localState.charge * 5);
        positions[i * 3 + 2] += particleVelocities[i].z * (1 + localState.charge * 5);

        const dist = Math.sqrt(
          positions[i * 3] ** 2 +
            positions[i * 3 + 1] ** 2 +
            positions[i * 3 + 2] ** 2
        );

        if (dist > 2) {
          positions[i * 3] = (Math.random() - 0.5) * 0.2;
          positions[i * 3 + 1] = (Math.random() - 0.5) * 0.2;
          positions[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
        }
      }

      particleGeometry.attributes.position.needsUpdate = true;
      pointLight.intensity = localState.charge * 5;

      bloomPass.strength = Math.max(0.4, localState.charge * 2);
      composer.render();
    };

    animate();

    const handleResize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    };

    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
      cancelAnimationFrame(animationId);
      if (mountRef.current) {
        mountRef.current.removeChild(renderer.domElement);
      }
      orbGeometry.dispose();
      orbMaterial.dispose();
      particleGeometry.dispose();
      particleMaterial.dispose();
      renderer.dispose();
    };
  }, [addEnergy, setCharge]);

  return <div ref={mountRef} className="fixed inset-0" />;
}
</file>

<file path="src/scraprun/ScrapRunOverlay.tsx">
import ScrapRunScene from './ScrapRunScene';
import { useGameStore } from '../core/GameState';

export default function ScrapRunOverlay() {
  const endRun = useGameStore((s) => s.endScrapRun);
  const upgrades = useGameStore((s) => s.upgrades);

  const handleGameOver = (score: number, collected: number) => {
    endRun(score, collected);
  };

  return (
    <div className="fixed inset-0 z-50">
      <ScrapRunScene onGameOver={handleGameOver} upgrades={upgrades} />
      <button
        className="absolute top-4 left-4 z-10 bg-red-600 hover:bg-red-700 px-6 py-3 rounded font-bold text-white"
        onClick={() => handleGameOver(0, 0)}
      >
        ABORT RUN
      </button>
    </div>
  );
}
</file>

<file path="src/scraprun/ScrapRunScene.tsx">
import { useEffect, useRef, useState } from 'react';
import type { MouseEvent, TouchEvent } from 'react';
import * as THREE from 'three';
import type { ScrapUpgradeId } from '../core/ScrapUnlocks';

type Props = {
  onGameOver: (score: number, collected: number) => void;
  upgrades: Record<ScrapUpgradeId, number>;
};

const BASE_GAME_CONFIG = {
  innerOrbit: -2,
  outerOrbit: 1,
  orbitSpeed: 0.08,
  strafeSpeed: 0.1,
  maxStrafe: 3,
  debrisSpeed: 0.15,
  spawnDistance: -40,
  despawnDistance: 8,
  spawnInterval: 1000,
  curvatureStrength: 0.15,
};

export default function ScrapRunScene({ onGameOver, upgrades }: Props) {
  const mountRef = useRef<HTMLDivElement>(null);
  const [isHolding, setIsHolding] = useState(false);
  const [touchStart, setTouchStart] = useState<number | null>(null);
  const [currentTouchX, setCurrentTouchX] = useState<number | null>(null);
  const [gameState, setGameState] = useState({
    score: 0,
    collected: 0,
    gameOver: false,
    shields: upgrades.shieldGenerator ?? 0,
  });

  useEffect(() => {
    if (!mountRef.current || gameState.gameOver) return;

    const afterburners = upgrades.afterburners ?? 0;
    const timeDilation = upgrades.timeDilation ?? 0;
    const config = {
      ...BASE_GAME_CONFIG,
      strafeSpeed: BASE_GAME_CONFIG.strafeSpeed + afterburners * 0.04,
      maxStrafe: BASE_GAME_CONFIG.maxStrafe + afterburners * 0.5,
      debrisSpeed: BASE_GAME_CONFIG.debrisSpeed * (1 - timeDilation * 0.12),
      spawnInterval: BASE_GAME_CONFIG.spawnInterval * (1 + timeDilation * 0.15),
      curvatureStrength: BASE_GAME_CONFIG.curvatureStrength,
    };

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a1a);
    scene.fog = new THREE.Fog(0x0a0a1a, 10, 50);

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 0, 10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    mountRef.current.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    const pointLight = new THREE.PointLight(0x4a90e2, 0.5);
    pointLight.position.set(0, 2, 8);
    scene.add(pointLight);

    const planetGeometry = new THREE.SphereGeometry(6, 32, 32);
    const planetMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a2e, wireframe: true });
    const planet = new THREE.Mesh(planetGeometry, planetMaterial);
    planet.position.set(0, -8, 0);
    planet.receiveShadow = true;
    scene.add(planet);

    const starsGeometry = new THREE.BufferGeometry();
    const starPositions: number[] = [];
    for (let i = 0; i < 200; i++) {
      starPositions.push(
        (Math.random() - 0.5) * 100,
        (Math.random() - 0.5) * 100,
        (Math.random() - 0.5) * 100 - 50
      );
    }
    starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
    const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);

    const playerGroup = new THREE.Group();
    playerGroup.position.set(0, config.innerOrbit, 5);
    scene.add(playerGroup);

    const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.6, 8);
    const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xe0e0e0 });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.castShadow = true;
    playerGroup.add(body);

    const capGeometry = new THREE.SphereGeometry(0.3, 8, 8);
    const topCap = new THREE.Mesh(capGeometry, bodyMaterial);
    topCap.position.y = 0.3;
    playerGroup.add(topCap);
    const bottomCap = new THREE.Mesh(capGeometry, bodyMaterial);
    bottomCap.position.y = -0.3;
    playerGroup.add(bottomCap);

    const helmetGeometry = new THREE.SphereGeometry(0.35, 16, 16);
    const helmetMaterial = new THREE.MeshLambertMaterial({
      color: 0x4a90e2,
      transparent: true,
      opacity: 0.7,
    });
    const helmet = new THREE.Mesh(helmetGeometry, helmetMaterial);
    helmet.position.y = 0.6;
    helmet.castShadow = true;
    playerGroup.add(helmet);

    const collectedJunk: THREE.Mesh[] = [];
    const debrisList: THREE.Mesh[] = [];
    let debrisIdCounter = 0;
    let lastSpawnTime = Date.now();

    let currentGameState = { ...gameState };
    let currentOrbitTarget = config.innerOrbit;
    let currentStrafeTarget = 0;
    let currentIsHolding = false;
    let currentTouchPos: number | null = null;

    const animate = () => {
      if (!currentGameState.gameOver) {
        requestAnimationFrame(animate);
      }

      planet.rotation.y += 0.002;

      const currentY = playerGroup.position.y;
      const newY = THREE.MathUtils.lerp(currentY, currentOrbitTarget, config.orbitSpeed);
      playerGroup.position.y = newY;

      const currentX = playerGroup.position.x;
      const newX = THREE.MathUtils.lerp(currentX, currentStrafeTarget, config.strafeSpeed);
      playerGroup.position.x = newX;

      playerGroup.rotation.y += 0.01;

      const now = Date.now();
      if (now - lastSpawnTime > config.spawnInterval) {
        lastSpawnTime = now;

        const isGood = Math.random() > 0.3;
        const geometry = isGood
          ? new THREE.BoxGeometry(0.4, 0.4, 0.4)
          : new THREE.OctahedronGeometry(0.5, 0);
        const material = new THREE.MeshLambertMaterial({
          color: isGood ? 0x4ade80 : 0xef4444,
        });
        const debris = new THREE.Mesh(geometry, material);

        const startX = (Math.random() - 0.5) * 6;
        const startY = (Math.random() - 0.5) * 4 - 1;

        debris.position.set(startX, startY, config.spawnDistance);
        debris.castShadow = true;
        debris.userData = {
          id: debrisIdCounter++,
          type: isGood ? 'good' : 'bad',
          initialX: startX,
          initialY: startY,
          rotationSpeed: { x: Math.random() * 0.04 - 0.02, y: Math.random() * 0.04 - 0.02 },
        };
        scene.add(debris);
        debrisList.push(debris);
      }

      const hitboxRadius =
        0.5 + currentGameState.collected * 0.1 + (upgrades.tractorBeam ?? 0) * 0.2;
      const playerPos = playerGroup.position;

      for (let i = debrisList.length - 1; i >= 0; i--) {
        const debris = debrisList[i];

        debris.position.z += config.debrisSpeed;

        const progress =
          (debris.position.z - config.spawnDistance) /
          (config.despawnDistance - config.spawnDistance);
        const curve = Math.sin(progress * Math.PI) * config.curvatureStrength;

        debris.position.x = debris.userData.initialX + debris.userData.initialX * curve * 0.5;
        debris.position.y = debris.userData.initialY + Math.abs(debris.userData.initialX) * curve;

        debris.rotation.x += debris.userData.rotationSpeed.x;
        debris.rotation.y += debris.userData.rotationSpeed.y;

        const distance = debris.position.distanceTo(playerPos);
        if (distance < hitboxRadius + 0.3) {
          scene.remove(debris);
          debrisList.splice(i, 1);

          if (debris.userData.type === 'good') {
            currentGameState.collected++;
            currentGameState.score += 10;
            setGameState({ ...currentGameState });

            const junkPiece = debris.clone();
            const angle = (collectedJunk.length / 20) * Math.PI * 2;
            const radius = 0.8 + Math.floor(collectedJunk.length / 20) * 0.3;
            junkPiece.position.set(
              Math.cos(angle) * radius,
              (Math.random() - 0.5) * 0.5,
              Math.sin(angle) * radius
            );
            junkPiece.scale.set(0.5, 0.5, 0.5);
            playerGroup.add(junkPiece);
            collectedJunk.push(junkPiece);
          } else {
            if (currentGameState.shields > 0) {
              currentGameState.shields -= 1;
              setGameState({ ...currentGameState });
            } else if (currentGameState.collected > 0) {
              const loseCount = Math.min(3, currentGameState.collected);
              currentGameState.collected -= loseCount;

              for (let j = 0; j < loseCount && collectedJunk.length > 0; j++) {
                const junk = collectedJunk.pop();
                if (junk) playerGroup.remove(junk);
              }

              setGameState({ ...currentGameState });
            } else {
              currentGameState.gameOver = true;
              setGameState({ ...currentGameState });
            }
          }
          continue;
        }

        if (debris.position.z > config.despawnDistance) {
          scene.remove(debris);
          debrisList.splice(i, 1);
        }
      }

      renderer.render(scene, camera);
    };

    animate();

    const handleResize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };
    window.addEventListener('resize', handleResize);

    const stateInterval = setInterval(() => {
      currentOrbitTarget = currentIsHolding ? config.outerOrbit : config.innerOrbit;

      if (currentTouchPos !== null) {
        const normalizedX = (currentTouchPos - window.innerWidth / 2) / (window.innerWidth / 2);
        currentStrafeTarget = normalizedX * config.maxStrafe;
      } else {
        currentStrafeTarget = 0;
      }
    }, 16);

    (window as unknown as Record<string, (value: any) => void>).updateHoldingState = (
      holding: boolean
    ) => {
      currentIsHolding = holding;
    };

    (window as unknown as Record<string, (value: any) => void>).updateTouchPosition = (
      x: number | null
    ) => {
      currentTouchPos = x;
    };

    return () => {
      window.removeEventListener('resize', handleResize);
      clearInterval(stateInterval);
      if (mountRef.current && renderer.domElement) {
        mountRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
    };
  }, [gameState.gameOver, upgrades]);

  useEffect(() => {
    const updater = (window as unknown as Record<string, (value: any) => void>).updateHoldingState;
    if (updater) updater(isHolding);
  }, [isHolding]);

  useEffect(() => {
    const updater = (window as unknown as Record<string, (value: any) => void>).updateTouchPosition;
    if (updater) updater(currentTouchX);
  }, [currentTouchX]);

  useEffect(() => {
    if (gameState.gameOver) {
      onGameOver(gameState.score, gameState.collected);
    }
  }, [gameState.gameOver, gameState.score, gameState.collected, onGameOver]);

  const handleAbort = () => {
    onGameOver(gameState.score, gameState.collected);
  };

  const handleTouchStart = (e: TouchEvent) => {
    setIsHolding(true);
    const touch = e.touches[0];
    setTouchStart(touch.clientX);
    setCurrentTouchX(touch.clientX);
  };

  const handleTouchMove = (e: TouchEvent) => {
    if (touchStart !== null) {
      const touch = e.touches[0];
      setCurrentTouchX(touch.clientX);
    }
  };

  const handleTouchEnd = () => {
    setIsHolding(false);
    setTouchStart(null);
    setCurrentTouchX(null);
  };

  const handleMouseDown = (e: MouseEvent) => {
    setIsHolding(true);
    setTouchStart(e.clientX);
    setCurrentTouchX(e.clientX);
  };

  const handleMouseMove = (e: MouseEvent) => {
    if (touchStart !== null && isHolding) {
      setCurrentTouchX(e.clientX);
    }
  };

  const handleMouseUp = () => {
    setIsHolding(false);
    setTouchStart(null);
    setCurrentTouchX(null);
  };

  return (
    <div className="fixed inset-0 bg-black">
      <div
        className="absolute top-5 left-0 right-0 z-10 text-center font-mono text-xl text-green-400"
        style={{ textShadow: '0 0 10px rgba(74, 222, 128, 0.5)' }}
      >
        <div>SCRAP: {gameState.collected} | SCORE: {gameState.score}</div>
        <div className="text-sm mt-1 text-purple-400">
          {isHolding ? '↑ OUTER ORBIT' : '↓ INNER ORBIT'}
        </div>
        {gameState.shields > 0 && (
          <div className="text-xs text-cyan-400 mt-1">Shields: {gameState.shields}</div>
        )}
      </div>

      {!gameState.gameOver && gameState.score === 0 && (
        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-10 text-white font-mono text-center bg-black bg-opacity-80 p-5 rounded-lg pointer-events-none">
          <div className="text-green-400 text-2xl mb-2">GREED vs GRAVITY</div>
          <div>HOLD SCREEN → OUTER ORBIT</div>
          <div>RELEASE → INNER ORBIT</div>
          <div className="mt-2">DRAG LEFT/RIGHT → STRAFE</div>
          <div className="mt-2 text-green-400">✓ Collect green junk</div>
          <div className="text-red-500">✖ Avoid red obstacles</div>
        </div>
      )}

      {gameState.gameOver && (
        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-10 text-white font-mono text-2xl text-center bg-black bg-opacity-90 p-10 rounded-lg">
          <div className="text-red-500 text-3xl mb-5">WRECKED</div>
          <div>Final Score: {gameState.score}</div>
          <div>Scrap Collected: {gameState.collected}</div>
          <button
            onClick={handleAbort}
            className="mt-5 px-8 py-3 text-lg bg-green-500 hover:bg-green-600 border-0 rounded cursor-pointer font-mono text-black font-bold"
          >
            RETURN TO ORB
          </button>
        </div>
      )}

      {!gameState.gameOver && (
        <button
          onClick={handleAbort}
          className="absolute top-5 right-5 z-10 px-6 py-3 bg-red-600 hover:bg-red-700 text-white rounded-lg font-bold"
        >
          ABORT RUN
        </button>
      )}

      <div
        className="absolute bottom-0 left-0 right-0 h-2/5 z-5"
        style={{ touchAction: 'none' }}
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        onTouchEnd={handleTouchEnd}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
      />

      <div ref={mountRef} className="w-full h-full" />
    </div>
  );
}
</file>

<file path="src/ui/MainMenu.tsx">
import { useEffect, useMemo, useState } from 'react';
import { useGameStore } from '../core/GameState';

const BASE_COOLDOWN_MS = 2 * 60 * 1000; // 2 minutes for MVP loop

export default function MainMenu() {
  const {
    energy,
    scrap,
    charge,
    lastRunTime,
    bestRunScore,
    prestigeLevel,
    cosmicEssence,
    upgrades,
    startScrapRun,
    prestige,
  } = useGameStore();

  const cooldownReduction = (upgrades.warpCooldown ?? 0) * 2 * 60 * 1000;
  const effectiveCooldown = useMemo(
    () => Math.max(30_000, BASE_COOLDOWN_MS - cooldownReduction),
    [cooldownReduction]
  );

  const [cooldownRemaining, setCooldownRemaining] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      const remaining = Math.max(0, effectiveCooldown - (Date.now() - lastRunTime));
      setCooldownRemaining(remaining);
    }, 100);

    return () => clearInterval(interval);
  }, [lastRunTime, effectiveCooldown]);

  const canLaunch = cooldownRemaining === 0;
  const canPrestige = energy >= 10000;

  const formatTime = (ms: number) => {
    const mins = Math.floor(ms / 60000);
    const secs = Math.floor((ms % 60000) / 1000);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <>
      <div className="fixed top-6 left-1/2 -translate-x-1/2 text-center z-10">
        <div className="glass px-8 py-4 rounded-lg border border-purple-500/60">
          <div className="text-purple-300 text-sm mb-1 tracking-wide">ENERGY</div>
          <div className="text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-400 font-mono drop-shadow">
            {Math.floor(energy)}
          </div>
          <div className="text-xs text-gray-400 mt-1">{(charge * 100).toFixed(0)}% charged</div>
        </div>
      </div>

      <div className="fixed top-28 left-1/2 -translate-x-1/2 z-10">
        <div className="w-64 h-4 bg-gray-800 rounded-full overflow-hidden border-2 border-purple-500">
          <div
            className="h-full bg-gradient-to-r from-purple-500 to-pink-500 transition-all duration-100"
            style={{ width: `${charge * 100}%` }}
          />
        </div>
      </div>

      <div className="fixed bottom-10 left-1/2 -translate-x-1/2 z-10">
        <div className="glass px-8 py-6 rounded-lg border-2 border-purple-600/60">
          <div className="flex gap-8 items-center">
            <div className="text-center">
              <button
                onClick={startScrapRun}
                disabled={!canLaunch}
                className={`px-8 py-4 rounded-lg font-bold text-lg transition-all ${
                  canLaunch
                    ? 'bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-500 hover:to-pink-500 text-white shadow-lg shadow-purple-500/50 border-0'
                    : 'bg-gray-700 text-gray-500 cursor-not-allowed border border-gray-700'
                }`}
              >
                {canLaunch ? 'LAUNCH SCRAP RUN' : `COOLDOWN ${formatTime(cooldownRemaining)}`}
              </button>
              <div className="text-xs text-gray-400 mt-2">
                {Math.floor(scrap)} Scrap | Best: {bestRunScore}
              </div>
            </div>

            <div className="text-center border-l-2 border-purple-700 pl-8">
              <button
                onClick={prestige}
                disabled={!canPrestige}
                className={`px-6 py-3 rounded-lg font-bold transition-all ${
                  canPrestige
                    ? 'bg-gradient-to-r from-yellow-600 to-orange-600 hover:from-yellow-500 hover:to-orange-500 text-white'
                    : 'bg-gray-700 text-gray-500 cursor-not-allowed border border-gray-700'
                }`}
              >
                PRESTIGE
              </button>
              <div className="text-xs text-gray-400 mt-2">
                Level {prestigeLevel} | ✦ {cosmicEssence} Essence
              </div>
              <div className="text-xs text-yellow-600 mt-1">
                {canPrestige
                  ? `+${Math.floor(Math.sqrt(energy / 10000))} Essence`
                  : 'Need 10,000 energy'}
              </div>
            </div>
          </div>
        </div>
      </div>

      <div className="fixed bottom-6 right-6 glass p-4 rounded-lg border border-purple-500 text-purple-200 text-sm max-w-xs">
        <div className="font-bold mb-2">Controls</div>
        <div>• Hold anywhere to charge the orb</div>
        <div>• Charge = more energy generation</div>
        <div>• Scrap Runs grant upgrades</div>
        <div className="mt-2 text-xs text-gray-400">
          Higher charge when launching gives better scrap multiplier.
        </div>
      </div>
    </>
  );
}
</file>

<file path="src/ui/UpgradePanel.tsx">
import { useState } from 'react';
import { SCRAP_UPGRADE_CATEGORIES, getUpgradeCost } from '../core/ScrapUnlocks';
import { useGameStore } from '../core/GameState';

export default function UpgradePanel() {
  const { scrap, upgrades, purchaseUpgrade } = useGameStore();
  const [expanded, setExpanded] = useState(true);
  const [activeCategory, setActiveCategory] = useState(SCRAP_UPGRADE_CATEGORIES[0].id);

  return (
    <div
      className={`fixed left-4 top-1/2 -translate-y-1/2 bg-gray-900 bg-opacity-95 rounded-lg border-2 border-purple-500 transition-all ${
        expanded ? 'w-80' : 'w-12'
      }`}
    >
      <button
        onClick={() => setExpanded(!expanded)}
        className="absolute -right-3 top-1/2 -translate-y-1/2 w-6 h-12 bg-purple-600 hover:bg-purple-500 rounded-r-lg flex items-center justify-center text-white font-bold"
      >
        {expanded ? '«' : '»'}
      </button>

      {expanded && (
        <div className="p-4">
          <div className="text-purple-300 font-bold text-lg mb-2">UPGRADES</div>
          <div className="flex gap-2 mb-4">
            {SCRAP_UPGRADE_CATEGORIES.map((category) => (
              <button
                key={category.id}
                onClick={() => setActiveCategory(category.id)}
                className={`flex-1 px-2 py-1 rounded text-xs font-bold border ${
                  activeCategory === category.id
                    ? 'bg-purple-700 border-purple-400 text-white'
                    : 'bg-gray-800 border-gray-700 text-gray-400'
                }`}
                style={
                  activeCategory === category.id ? { boxShadow: `0 0 12px ${category.accent}` } : {}
                }
              >
                {category.label}
              </button>
            ))}
          </div>
          <div className="mb-4 text-yellow-400 font-mono">☆ {Math.floor(scrap)} Scrap</div>

          <div className="space-y-3">
            {SCRAP_UPGRADE_CATEGORIES.find((c) => c.id === activeCategory)?.upgrades.map(
              (upgrade) => {
                const level = upgrades[upgrade.id] ?? 0;
                const cost = getUpgradeCost(upgrade.id, level);
                const maxed = level >= upgrade.max;
                const canAfford = scrap >= cost;

                return (
                  <button
                    key={upgrade.id}
                    onClick={() => purchaseUpgrade(upgrade.id)}
                    disabled={!canAfford || maxed}
                    className={`w-full p-3 rounded-lg border-2 text-left transition-all ${
                      maxed
                        ? 'border-green-500 bg-green-900 bg-opacity-30'
                        : canAfford
                          ? 'border-purple-500 bg-purple-900 bg-opacity-30 hover:bg-opacity-50'
                          : 'border-gray-700 bg-gray-800 bg-opacity-30 opacity-60'
                    }`}
                  >
                    <div className="text-white font-bold text-sm">{upgrade.label}</div>
                    <div className="text-gray-400 text-xs mb-1">{upgrade.desc}</div>
                    <div className="flex justify-between items-center text-xs">
                      <span className={maxed ? 'text-green-400' : 'text-purple-300'}>
                        {maxed ? 'MAX' : `Level ${level}/${upgrade.max}`}
                      </span>
                      {!maxed && <span className="text-yellow-400">☆ {cost}</span>}
                    </div>
                  </button>
                );
              }
            )}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "composite": true,
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "types": ["vite/client"]
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.d.ts">
declare const _default: import("vite").UserConfig;
export default _default;
</file>

<file path="vite.config.js">
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
export default defineConfig({
    plugins: [react()],
    server: {
        port: 5173,
    },
});
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
  },
});
</file>

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist/

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*
</file>

<file path="README.md">
# Orb Ascent

Hybrid idle orb + scrap-run mini-game built with React, Three.js, and Zustand.

## Getting started

1. Install dependencies: `npm install`
2. Start dev server: `npm run dev`
3. Build for production: `npm run build` then preview with `npm run preview`

## Structure

- `src/core` — Zustand store and upgrade definitions
- `src/orb` — 3D orb scene, energy generation
- `src/scraprun` — full-screen runner overlay
- `src/ui` — HUD, cooldown, upgrade panel
</file>

</files>
