This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: plan.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitattributes
.github/workflows/deploy.yml
.gitignore
index.html
package.json
README.md
src/App.tsx
src/core/GameState.ts
src/core/ScrapUnlocks.ts
src/devtools/DebrisLab.tsx
src/devtools/DevToolsHub.tsx
src/devtools/GameStateInspector.tsx
src/devtools/OrbDebug.tsx
src/devtools/PlaceholderTool.tsx
src/devtools/PrestigeSim.tsx
src/devtools/ShaderLab.tsx
src/devtools/UpgradeSim.tsx
src/index.css
src/main.tsx
src/orb/orbMaterial.ts
src/orb/orbPresets.ts
src/orb/OrbScene.tsx
src/scraprun/config.ts
src/scraprun/ScrapRunOverlay.tsx
src/scraprun/ScrapRunScene.tsx
src/types.d.ts
src/ui/MainMenu.tsx
src/ui/UpgradePanel.tsx
src/vite-env.d.ts
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.d.ts
vite.config.js
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path=".github/workflows/deploy.yml">
name: Deploy to GitHub Pages

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Build
        run: npm run build

      - name: Upload production-ready files
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./dist

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Trashball</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "orb-ascent",
  "version": "1.0.0",
  "description": "",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview",
    "lint": "echo \"No lint configured\""
  },
  "keywords": [],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "three": "^0.181.2",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@tailwindcss/vite": "^4.1.17",
    "@types/react": "^19.2.6",
    "@types/react-dom": "^19.2.3",
    "@types/three": "^0.181.0",
    "@vitejs/plugin-react": "^5.1.1",
    "tailwindcss": "^4.0.0",
    "typescript": "^5.9.3",
    "vite": "^7.2.4"
  }
}
</file>

<file path="src/App.tsx">
import type React from 'react';
import { useMemo, useState } from 'react';
import OrbScene from './orb/OrbScene';
import ScrapRunOverlay from './scraprun/ScrapRunOverlay';
import MainMenu from './ui/MainMenu';
import UpgradePanel from './ui/UpgradePanel';
import DevToolsHub from './devtools/DevToolsHub';
import { useGameStore } from './core/GameState';

function getDevToolFromLocation() {
  const params = new URLSearchParams(window.location.search);
  return params.get('devTool');
}

export default function App() {
  const devTool = useMemo(() => (__DEV_TOOLS__ ? getDevToolFromLocation() : null), []);
  const scrapRunActive = useGameStore((s) => s.scrapRunActive);
  const [isHolding, setIsHolding] = useState(false);

  const enableHold = () => setIsHolding(true);
  const disableHold = () => setIsHolding(false);

  if (devTool) {
    const initialTool = devTool === 'true' ? null : devTool;
    return <DevToolsHub initialTool={initialTool} />;
  }

  const handleTouchStart: React.TouchEventHandler<HTMLDivElement> = (e) => {
    if (scrapRunActive) return;
    const touch = e.touches[0];
    const target = e.currentTarget.getBoundingClientRect();
    const y = touch.clientY - target.top;
    const topBand = target.height * 0.2;
    const bottomBand = target.height * 0.8;

    if (y > topBand && y < bottomBand) {
      e.preventDefault();
      enableHold();
    }
  };

  return (
    <div
      className="relative w-full min-h-[100dvh] overflow-hidden select-none bg-gradient-to-b from-[#05070f] to-[#020308] touch-none"
      onMouseDown={!scrapRunActive ? enableHold : undefined}
      onMouseUp={!scrapRunActive ? disableHold : undefined}
      onMouseLeave={!scrapRunActive ? disableHold : undefined}
      onTouchStart={handleTouchStart}
      onTouchEnd={!scrapRunActive ? disableHold : undefined}
    >
      {!scrapRunActive && <OrbScene isHolding={isHolding} />}

      {scrapRunActive ? (
        <ScrapRunOverlay />
      ) : (
        <>
          <MainMenu />
          <UpgradePanel />
        </>
      )}
    </div>
  );
}
</file>

<file path="src/core/GameState.ts">
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { SCRAP_UPGRADES, ScrapUpgradeId, getUpgradeCost } from './ScrapUnlocks';

export type PhysicsParams = {
  gravity: number;
  thrustForce: number;
  terminalVelocity: number;
  chargeDamping: number;
};

type GameValues = {
  energy: number;
  totalEnergy: number;
  charge: number;
  scrap: number;
  totalScrap: number;
  lastRunTime: number;
  bestRunScore: number;
  scrapRunActive: boolean;
  prestigeLevel: number;
  cosmicEssence: number;
  physics: PhysicsParams;
  upgrades: Record<ScrapUpgradeId, number>;
};

export type GameStore = GameValues & {
  addEnergy: (n: number) => void;
  setCharge: (n: number) => void;
  addScrap: (n: number) => void;
  startScrapRun: () => void;
  endScrapRun: (score: number, collected: number) => void;
  purchaseUpgrade: (id: ScrapUpgradeId) => void;
  prestige: () => void;
  devSetState?: (partial: Partial<GameValues>) => void;
  devReset?: () => void;
  devAdjustUpgrade?: (id: ScrapUpgradeId, delta: number) => void;
};

const initialPhysics: PhysicsParams = {
  gravity: 0.5,
  thrustForce: 1.2,
  terminalVelocity: 5,
  chargeDamping: 0.95,
};

const calculateEssence = (totalEnergy: number) => Math.floor(Math.sqrt(totalEnergy / 10000));

const buildInitialState = (): GameValues => ({
  energy: 0,
  totalEnergy: 0,
  charge: 0,
  scrap: 0,
  totalScrap: 0,
  lastRunTime: 0,
  bestRunScore: 0,
  scrapRunActive: false,
  prestigeLevel: 0,
  cosmicEssence: 0,
  physics: { ...initialPhysics },
  upgrades: {} as Record<ScrapUpgradeId, number>,
});

export const useGameStore = create<GameStore>()(
  persist(
    (set) => ({
      ...buildInitialState(),

      addEnergy: (n) =>
        set((state) => ({
          energy: state.energy + n,
          totalEnergy: state.totalEnergy + n,
        })),

      setCharge: (n) => set({ charge: Math.max(0, Math.min(1, n)) }),

      addScrap: (n) =>
        set((state) => ({
          scrap: state.scrap + n,
          totalScrap: state.totalScrap + n,
        })),

      startScrapRun: () => set({ scrapRunActive: true, lastRunTime: Date.now() }),

      endScrapRun: (score, collected) =>
        set((state) => {
          const baseScrap = Math.floor(score / 10);
          const chargeBonus = state.charge > 0.9 ? 1.5 : 1;
          const prestigeBonus = 1 + state.prestigeLevel * 0.1;
          const scrapEarned = Math.floor((baseScrap + collected) * chargeBonus * prestigeBonus);

          return {
            scrap: state.scrap + scrapEarned,
            totalScrap: state.totalScrap + scrapEarned,
            bestRunScore: Math.max(state.bestRunScore, score),
            scrapRunActive: false,
            charge: 0,
          };
        }),

      purchaseUpgrade: (id) =>
        set((state) => {
          const currentLevel = state.upgrades[id] ?? 0;
          const upgrade = SCRAP_UPGRADES[id];
          if (currentLevel >= upgrade.max) return state;

          const cost = getUpgradeCost(id, currentLevel);
          if (state.scrap < cost) return state;

          return {
            scrap: state.scrap - cost,
            upgrades: { ...state.upgrades, [id]: currentLevel + 1 },
          };
        }),

      prestige: () =>
        set((state) => ({
          energy: 0,
          scrap: 0,
          upgrades: {} as Record<ScrapUpgradeId, number>,
          prestigeLevel: state.prestigeLevel + 1,
          cosmicEssence: state.cosmicEssence + calculateEssence(state.totalEnergy),
        })),
      devSetState: __DEV_TOOLS__
        ? (partial) =>
            set((state) => {
              const next: Partial<GameStore> = {};

              if (partial.physics) {
                next.physics = { ...state.physics, ...partial.physics };
              }
              if (partial.upgrades) {
                next.upgrades = { ...state.upgrades, ...partial.upgrades };
              }

              const { physics, upgrades, ...rest } = partial;
              return { ...rest, ...next };
            })
        : undefined,
      devReset: __DEV_TOOLS__
        ? () =>
            set(() => ({
              ...buildInitialState(),
            }))
        : undefined,
      devAdjustUpgrade: __DEV_TOOLS__
        ? (id, delta) =>
            set((state) => {
              const current = state.upgrades[id] ?? 0;
              const upgrade = SCRAP_UPGRADES[id];
              const nextLevel = Math.max(0, Math.min(upgrade.max, current + delta));
              if (nextLevel === current) return state;
              return { upgrades: { ...state.upgrades, [id]: nextLevel } };
            })
        : undefined,
    }),
    { name: 'orb-ascent-save' }
  )
);
</file>

<file path="src/core/ScrapUnlocks.ts">
export type ScrapUpgradeId =
  | 'resonanceTuner'
  | 'criticalSurge'
  | 'orbitalStabilization'
  | 'tractorBeam'
  | 'shieldGenerator'
  | 'afterburners'
  | 'warpCooldown'
  | 'timeDilation';

export type ScrapUpgrade = {
  id: ScrapUpgradeId;
  baseCost: number;
  scale: number;
  max: number;
  label: string;
  desc: string;
};

export type ScrapUpgradeCategory = {
  id: 'harmonic' | 'scavenger' | 'chronos';
  label: string;
  accent: string;
  upgrades: ScrapUpgrade[];
};

export const SCRAP_UPGRADE_CATEGORIES: ScrapUpgradeCategory[] = [
  {
    id: 'harmonic',
    label: 'Compactors',
    accent: '#f97316',
    upgrades: [
      {
        id: 'resonanceTuner',
        baseCost: 100,
        scale: 1.8,
        max: 15,
        label: 'Compactor Rhythm',
        desc: '+15% trash compression per level',
      },
      {
        id: 'criticalSurge',
        baseCost: 400,
        scale: 2,
        max: 5,
        label: 'Toxic Surge',
        desc: '5% chance per level to ignite a 10x burn tick while holding',
      },
      {
        id: 'orbitalStabilization',
        baseCost: 750,
        scale: 2.1,
        max: 5,
        label: 'Gyro Binders',
        desc: 'Locks charge longer when you let go',
      },
    ],
  },
  {
    id: 'scavenger',
    label: 'Scavengers',
    accent: '#22c55e',
    upgrades: [
      {
        id: 'tractorBeam',
        baseCost: 500,
        scale: 2,
        max: 5,
        label: 'Junk Magnet',
        desc: 'Pull in stray trash from further away',
      },
      {
        id: 'shieldGenerator',
        baseCost: 900,
        scale: 2.2,
        max: 3,
        label: 'Hazmat Shielding',
        desc: 'Ignore one collision per shield charge',
      },
      {
        id: 'afterburners',
        baseCost: 1200,
        scale: 2.3,
        max: 3,
        label: 'Thruster Fins',
        desc: 'Sharper strafe speed for lane changes',
      },
    ],
  },
  {
    id: 'chronos',
    label: 'Time-Shifted Landfill',
    accent: '#38bdf8',
    upgrades: [
      {
        id: 'warpCooldown',
        baseCost: 1500,
        scale: 2.6,
        max: 5,
        label: 'Warp Breaker',
        desc: '-2 min launch cooldown per level',
      },
      {
        id: 'timeDilation',
        baseCost: 2000,
        scale: 2.8,
        max: 3,
        label: 'Landfill Slowdown',
        desc: 'Trash tunnel debris moves slower',
      },
    ],
  },
];

export const SCRAP_UPGRADES: Record<ScrapUpgradeId, ScrapUpgrade> = SCRAP_UPGRADE_CATEGORIES.reduce(
  (map, category) => {
    category.upgrades.forEach((upgrade) => {
      map[upgrade.id] = upgrade;
    });
    return map;
  },
  {} as Record<ScrapUpgradeId, ScrapUpgrade>
);

export const getUpgradeCost = (id: ScrapUpgradeId, currentLevel: number): number => {
  const upgrade = SCRAP_UPGRADES[id];
  return Math.floor(upgrade.baseCost * Math.pow(upgrade.scale, currentLevel));
};
</file>

<file path="src/devtools/DebrisLab.tsx">
import { useMemo, useState } from 'react';
import ScrapRunScene from '../scraprun/ScrapRunScene';
import { BASE_GAME_CONFIG, type ScrapRunConfig } from '../scraprun/config';
import type { ScrapUpgradeId } from '../core/ScrapUnlocks';

const numberField = (n: number, decimals = 2) => Number(n.toFixed(decimals));

export default function DebrisLab() {
  const [config, setConfig] = useState<ScrapRunConfig>(BASE_GAME_CONFIG);
  const [showCurvature, setShowCurvature] = useState(true);
  const [showHitboxes, setShowHitboxes] = useState(true);

  const memoConfig = useMemo(() => ({ ...config }), [config]);

  const updateConfig = <K extends keyof ScrapRunConfig>(key: K, value: ScrapRunConfig[K]) => {
    setConfig((prev) => ({ ...prev, [key]: value }));
  };

  return (
    <div className="grid grid-cols-1 lg:grid-cols-[2fr_1fr] min-h-screen bg-slate-950 text-slate-100">
      <div className="relative">
        <ScrapRunScene
          onGameOver={() => {}}
          upgrades={{} as Record<ScrapUpgradeId, number>}
          config={memoConfig}
          showCurvatureDebug={showCurvature}
          showHitboxes={showHitboxes}
          minimalUi
          endless
        />
        <div className="absolute top-4 left-4 bg-black/50 px-3 py-2 rounded text-xs text-slate-300">
          Dev Tool: DebrisLab - use ?devTool=debris
        </div>
      </div>

      <div className="p-6 space-y-4 bg-slate-900/80 border-l border-slate-800 overflow-y-auto">
        <div className="flex items-center justify-between">
          <div>
            <div className="text-xs text-slate-500 uppercase">Sandbox</div>
            <div className="text-lg font-semibold">ScrapRun Debris Tuner</div>
          </div>
          <button
            onClick={() => setConfig(BASE_GAME_CONFIG)}
            className="px-3 py-2 bg-slate-800 hover:bg-slate-700 rounded text-sm"
          >
            Reset to Base
          </button>
        </div>

        <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
          <NumberSlider
            label="Spawn Interval (ms)"
            value={config.spawnInterval}
            min={200}
            max={2000}
            step={50}
            onChange={(v) => updateConfig('spawnInterval', Math.max(50, Math.round(v)))}
          />
          <NumberSlider
            label="Spawn Distance (Z)"
            value={config.spawnDistance}
            min={-80}
            max={-10}
            step={1}
            onChange={(v) => updateConfig('spawnDistance', numberField(v, 0))}
          />
          <NumberSlider
            label="Despawn Distance (Z)"
            value={config.despawnDistance}
            min={2}
            max={20}
            step={0.5}
            onChange={(v) => updateConfig('despawnDistance', numberField(v))}
          />
          <NumberSlider
            label="Debris Speed"
            value={config.debrisSpeed}
            min={0.05}
            max={0.6}
            step={0.01}
            onChange={(v) => updateConfig('debrisSpeed', numberField(v, 3))}
          />
          <NumberSlider
            label="Curvature Strength"
            value={config.curvatureStrength}
            min={0}
            max={0.6}
            step={0.01}
            onChange={(v) => updateConfig('curvatureStrength', numberField(v, 3))}
          />
          <NumberSlider
            label="Strafe Speed"
            value={config.strafeSpeed}
            min={0.02}
            max={0.4}
            step={0.01}
            onChange={(v) => updateConfig('strafeSpeed', numberField(v, 3))}
          />
          <NumberSlider
            label="Max Strafe"
            value={config.maxStrafe}
            min={1}
            max={8}
            step={0.1}
            onChange={(v) => updateConfig('maxStrafe', numberField(v, 2))}
          />
          <NumberSlider
            label="Good Ratio"
            value={config.goodRatio}
            min={0}
            max={1}
            step={0.02}
            onChange={(v) => updateConfig('goodRatio', numberField(v, 3))}
          />
          <NumberSlider
            label="Inner Orbit"
            value={config.innerOrbit}
            min={-5}
            max={0}
            step={0.1}
            onChange={(v) => updateConfig('innerOrbit', numberField(v, 2))}
          />
          <NumberSlider
            label="Outer Orbit"
            value={config.outerOrbit}
            min={0}
            max={4}
            step={0.1}
            onChange={(v) => updateConfig('outerOrbit', numberField(v, 2))}
          />
          <NumberSlider
            label="Orbit Lerp Speed"
            value={config.orbitSpeed}
            min={0.02}
            max={0.2}
            step={0.01}
            onChange={(v) => updateConfig('orbitSpeed', numberField(v, 3))}
          />
        </div>

        <div className="flex items-center gap-4">
          <label className="flex items-center gap-2 text-sm text-slate-200">
            <input
              type="checkbox"
              checked={showCurvature}
              onChange={(e) => setShowCurvature(e.target.checked)}
            />
            Show Curvature Debug
          </label>
          <label className="flex items-center gap-2 text-sm text-slate-200">
            <input
              type="checkbox"
              checked={showHitboxes}
              onChange={(e) => setShowHitboxes(e.target.checked)}
            />
            Show Hitboxes
          </label>
        </div>

        <div className="text-xs text-slate-500 leading-relaxed">
          Endless loop is enabled in this lab so crashes won&apos;t exit the scene. Adjust spawn and
          curve to feel out difficulty without playing full runs.
        </div>
      </div>
    </div>
  );
}

function NumberSlider({
  label,
  value,
  min,
  max,
  step,
  onChange,
}: {
  label: string;
  value: number;
  min: number;
  max: number;
  step: number;
  onChange: (val: number) => void;
}) {
  return (
    <label className="block text-xs text-slate-300 space-y-1">
      <div className="flex items-center justify-between">
        <span>{label}</span>
        <span className="text-slate-100 font-semibold">{value}</span>
      </div>
      <input
        type="range"
        min={min}
        max={max}
        step={step}
        value={value}
        onChange={(e) => onChange(Number(e.target.value))}
        className="w-full"
      />
    </label>
  );
}
</file>

<file path="src/devtools/DevToolsHub.tsx">
import { useEffect, useMemo, useState, type ComponentType } from 'react';
import ShaderLab from './ShaderLab';
import DebrisLab from './DebrisLab';
import UpgradeSim from './UpgradeSim';
import PrestigeSim from './PrestigeSim';
import OrbDebug from './OrbDebug';
import GameStateInspector from './GameStateInspector';

type DevToolId = 'shader' | 'debris' | 'upgrade' | 'prestige' | 'orbdebug' | 'state';

const DEV_TOOLS: Array<{
  id: DevToolId;
  label: string;
  description: string;
  component: ComponentType;
}> = [
  {
    id: 'shader',
    label: 'Shader Lab',
    description: 'Orb shader playground for gradients, wobble, and bloom.',
    component: ShaderLab,
  },
  {
    id: 'debris',
    label: 'Debris Lab',
    description: 'Tune ScrapRun debris spawns, paths, and debugging overlays.',
    component: DebrisLab,
  },
  {
    id: 'upgrade',
    label: 'Upgrade Sim',
    description: 'Placeholder for upgrade pacing and scaling experiments.',
    component: UpgradeSim,
  },
  {
    id: 'prestige',
    label: 'Prestige Sim',
    description: 'Placeholder for prestige loop simulations.',
    component: PrestigeSim,
  },
  {
    id: 'orbdebug',
    label: 'Orb Debug',
    description: 'Placeholder for orb physics and input visualizers.',
    component: OrbDebug,
  },
  {
    id: 'state',
    label: 'Game State Inspector',
    description: 'Live snapshot with resource editing and upgrade controls.',
    component: GameStateInspector,
  },
];

type Props = {
  initialTool: string | null;
};

export default function DevToolsHub({ initialTool }: Props) {
  const fallback = DEV_TOOLS[0];

  const initialId = useMemo<DevToolId>(() => {
    const match = DEV_TOOLS.find((tool) => tool.id === initialTool);
    return match?.id ?? fallback.id;
  }, [initialTool, fallback.id]);

  const [activeTool, setActiveTool] = useState<DevToolId>(initialId);

  useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    params.set('devTool', activeTool);
    const url = `${window.location.pathname}?${params.toString()}`;
    window.history.replaceState(null, '', url);
  }, [activeTool]);

  const active = DEV_TOOLS.find((tool) => tool.id === activeTool) ?? fallback;
  const ActiveComponent = active.component;

  return (
    <div className="relative min-h-screen bg-slate-950 text-slate-100">
      <ActiveComponent />

      <div className="fixed top-4 right-4 z-[60] w-80 max-h-[75vh] overflow-hidden rounded-xl border border-slate-800 bg-slate-900/90 shadow-2xl backdrop-blur">
        <div className="px-4 py-3 border-b border-slate-800">
          <div className="text-[10px] uppercase tracking-[0.2em] text-slate-500">Dev Tools</div>
          <div className="text-sm text-slate-200">Switch panels (devTool=true)</div>
        </div>
        <div className="divide-y divide-slate-800 overflow-y-auto max-h-[65vh]">
          {DEV_TOOLS.map((tool) => (
            <button
              key={tool.id}
              onClick={() => setActiveTool(tool.id)}
              className={`w-full text-left px-4 py-3 transition hover:bg-slate-800/70 ${
                activeTool === tool.id ? 'bg-slate-800/80' : ''
              }`}
            >
              <div className="flex items-center justify-between">
                <div className="text-sm font-semibold text-white">{tool.label}</div>
                {activeTool === tool.id && (
                  <span className="text-[11px] text-cyan-400 font-semibold">Active</span>
                )}
              </div>
              <div className="text-xs text-slate-400 mt-1 leading-snug">{tool.description}</div>
              <div className="text-[11px] text-slate-500 mt-1">?devTool={tool.id}</div>
            </button>
          ))}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/devtools/GameStateInspector.tsx">
import { useEffect, useMemo, useState, type ReactNode } from 'react';
import { useGameStore } from '../core/GameState';
import { SCRAP_UPGRADE_CATEGORIES, ScrapUpgradeId } from '../core/ScrapUnlocks';

const ENERGY_STEP = [100, 1000, 5000];
const SCRAP_STEP = [100, 500, 2000];
const BASE_COOLDOWN_MS = 2 * 60 * 1000;

export default function GameStateInspector() {
  const {
    energy,
    totalEnergy,
    scrap,
    totalScrap,
    charge,
    prestigeLevel,
    cosmicEssence,
    lastRunTime,
    scrapRunActive,
    upgrades,
    devSetState,
    devReset,
    devAdjustUpgrade,
  } = useGameStore();

  const [cooldownRemaining, setCooldownRemaining] = useState(0);

  const effectiveCooldown = useMemo(() => {
    const cooldownReduction = (upgrades.warpCooldown ?? 0) * 2 * 60 * 1000;
    return Math.max(30_000, BASE_COOLDOWN_MS - cooldownReduction);
  }, [upgrades.warpCooldown]);

  useEffect(() => {
    const tick = () => {
      const remaining = Math.max(0, effectiveCooldown - (Date.now() - lastRunTime));
      setCooldownRemaining(remaining);
    };
    tick();
    const id = setInterval(tick, 250);
    return () => clearInterval(id);
  }, [effectiveCooldown, lastRunTime]);

  const adjustEnergy = (delta: number) => {
    const nextEnergy = Math.max(0, energy + delta);
    const totalDelta = delta > 0 ? delta : 0;
    devSetState?.({
      energy: nextEnergy,
      totalEnergy: Math.max(0, totalEnergy + totalDelta),
    });
  };

  const adjustScrap = (delta: number) => {
    const nextScrap = Math.max(0, scrap + delta);
    const totalDelta = delta > 0 ? delta : 0;
    devSetState?.({
      scrap: nextScrap,
      totalScrap: Math.max(0, totalScrap + totalDelta),
    });
  };

  const setCooldownReady = () => devSetState?.({ lastRunTime: 0 });
  const setCooldownRecent = () => devSetState?.({ lastRunTime: Date.now() - 10_000 });

  const formatMs = (ms: number) => {
    const mins = Math.floor(ms / 60000);
    const secs = Math.floor((ms % 60000) / 1000);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const handleUpgradeChange = (id: ScrapUpgradeId, delta: number) => {
    devAdjustUpgrade?.(id, delta);
  };

  return (
    <div className="min-h-screen bg-slate-950 text-slate-100 font-mono">
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6 p-6">
        <div className="md:col-span-2 bg-slate-900/80 border border-slate-700 rounded-xl p-5 shadow-lg">
          <div className="flex justify-between items-center mb-4">
            <div>
              <div className="text-xs text-slate-400">DEV TOOL</div>
              <div className="text-2xl font-bold text-cyan-300">Game State Inspector</div>
            </div>
            <button
              onClick={() => devReset?.()}
              className="px-3 py-2 bg-red-600 hover:bg-red-500 rounded text-sm font-bold"
            >
              Reset Save
            </button>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <Panel title="Resources">
              <ResourceRow
                label="Energy"
                value={energy}
                steps={ENERGY_STEP}
                onAdjust={adjustEnergy}
              />
              <ResourceRow
                label="Scrap"
                value={scrap}
                steps={SCRAP_STEP}
                onAdjust={adjustScrap}
              />
              <SimpleField
                label="Charge"
                value={`${(charge * 100).toFixed(0)}%`}
                onSet={(val) => devSetState?.({ charge: Math.min(1, Math.max(0, val / 100)) })}
              />
              <SimpleField
                label="Cosmic Essence"
                value={cosmicEssence}
                onSet={(val) => devSetState?.({ cosmicEssence: Math.max(0, Math.floor(val)) })}
              />
              <SimpleField
                label="Prestige Level"
                value={prestigeLevel}
                onSet={(val) => devSetState?.({ prestigeLevel: Math.max(0, Math.floor(val)) })}
              />
            </Panel>

            <Panel title="Runs & Cooldown">
              <div className="flex items-center justify-between mb-3">
                <div>
                  <div className="text-xs text-slate-500">Cooldown Remaining</div>
                  <div className="text-lg text-amber-300">{formatMs(cooldownRemaining)}</div>
                </div>
                <div className="space-x-2">
                  <button
                    onClick={setCooldownReady}
                    className="px-3 py-2 bg-emerald-600 hover:bg-emerald-500 rounded text-sm"
                  >
                    Reset Cooldown
                  </button>
                  <button
                    onClick={setCooldownRecent}
                    className="px-3 py-2 bg-slate-700 hover:bg-slate-600 rounded text-sm"
                  >
                    Simulate Run
                  </button>
                </div>
              </div>
              <div className="flex items-center justify-between">
                <div className="text-sm">
                  Scrap Run Active: <span className="text-cyan-300">{scrapRunActive ? 'Yes' : 'No'}</span>
                </div>
                <button
                  onClick={() => devSetState?.({ scrapRunActive: !scrapRunActive })}
                  className="px-3 py-1 rounded bg-purple-700 hover:bg-purple-600 text-xs"
                >
                  Toggle
                </button>
              </div>
            </Panel>

            <Panel title="Upgrades">
              <div className="space-y-3 max-h-[340px] overflow-y-auto pr-1">
                {SCRAP_UPGRADE_CATEGORIES.map((category) => (
                  <div key={category.id}>
                    <div className="text-xs text-slate-500 uppercase tracking-wide mb-1">
                      {category.label}
                    </div>
                    <div className="space-y-2">
                      {category.upgrades.map((upgrade) => {
                        const level = upgrades[upgrade.id] ?? 0;
                        return (
                          <div
                            key={upgrade.id}
                            className="flex items-center justify-between rounded border border-slate-700 bg-slate-800/60 px-3 py-2"
                          >
                            <div>
                              <div className="text-sm text-white">{upgrade.label}</div>
                              <div className="text-[11px] text-slate-400">
                                Level {level}/{upgrade.max}
                              </div>
                            </div>
                            <div className="flex items-center gap-2">
                              <button
                                onClick={() => handleUpgradeChange(upgrade.id, -1)}
                                className="px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded text-xs"
                              >
                                -
                              </button>
                              <span className="w-6 text-center text-cyan-300">{level}</span>
                              <button
                                onClick={() => handleUpgradeChange(upgrade.id, 1)}
                                className="px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded text-xs"
                              >
                                +
                              </button>
                              <button
                                onClick={() => handleUpgradeChange(upgrade.id, upgrade.max)}
                                className="px-2 py-1 bg-emerald-700 hover:bg-emerald-600 rounded text-xs"
                              >
                                Max
                              </button>
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                ))}
              </div>
            </Panel>

            <Panel title="Quick Fill">
              <div className="grid grid-cols-2 gap-2">
                <button
                  onClick={() => adjustEnergy(10_000)}
                  className="px-3 py-2 bg-cyan-700 hover:bg-cyan-600 rounded text-sm"
                >
                  +10k Energy
                </button>
                <button
                  onClick={() => adjustEnergy(-energy)}
                  className="px-3 py-2 bg-slate-700 hover:bg-slate-600 rounded text-sm"
                >
                  Zero Energy
                </button>
                <button
                  onClick={() => adjustScrap(5_000)}
                  className="px-3 py-2 bg-amber-700 hover:bg-amber-600 rounded text-sm"
                >
                  +5k Scrap
                </button>
                <button
                  onClick={() => adjustScrap(-scrap)}
                  className="px-3 py-2 bg-slate-700 hover:bg-slate-600 rounded text-sm"
                >
                  Zero Scrap
                </button>
              </div>
              <div className="mt-4 text-xs text-slate-400 leading-relaxed">
                Use query `?devTool=state` to open this panel. All changes use in-memory dev actions
                so you can experiment without touching the main loop flow.
              </div>
            </Panel>
          </div>
        </div>

        <div className="bg-slate-900/80 border border-slate-700 rounded-xl p-5 shadow-lg space-y-4">
          <div>
            <div className="text-xs text-slate-500">Status</div>
            <div className="text-lg text-emerald-300 font-bold">Live Game Snapshot</div>
          </div>
          <StatusRow label="Energy" value={Math.floor(energy).toLocaleString()} />
          <StatusRow label="Total Energy" value={Math.floor(totalEnergy).toLocaleString()} />
          <StatusRow label="Scrap" value={Math.floor(scrap).toLocaleString()} />
          <StatusRow label="Total Scrap" value={Math.floor(totalScrap).toLocaleString()} />
          <StatusRow label="Charge" value={`${(charge * 100).toFixed(0)}%`} />
          <StatusRow label="Prestige" value={`Lv ${prestigeLevel}`} />
          <StatusRow label="Essence" value={cosmicEssence.toString()} />
          <StatusRow label="Run Active" value={scrapRunActive ? 'Yes' : 'No'} />
          <div className="text-[11px] text-slate-500 pt-2 border-t border-slate-800">
            Dev toggles are guarded by `__DEV_TOOLS__`. Flip the Vite define to disable in prod.
          </div>
        </div>
      </div>
    </div>
  );
}

function Panel({ title, children }: { title: string; children: ReactNode }) {
  return (
    <div className="rounded-lg border border-slate-800 bg-slate-900/70 p-4">
      <div className="text-sm text-slate-300 font-semibold mb-3">{title}</div>
      {children}
    </div>
  );
}

function StatusRow({ label, value }: { label: string; value: string }) {
  return (
    <div className="flex items-center justify-between text-sm">
      <span className="text-slate-400">{label}</span>
      <span className="text-white font-semibold">{value}</span>
    </div>
  );
}

function ResourceRow({
  label,
  value,
  steps,
  onAdjust,
}: {
  label: string;
  value: number;
  steps: number[];
  onAdjust: (n: number) => void;
}) {
  return (
    <div className="mb-3">
      <div className="flex items-center justify-between">
        <div className="text-sm text-white">{label}</div>
        <div className="text-sm text-cyan-300">{Math.floor(value)}</div>
      </div>
      <div className="flex gap-2 mt-2">
        {steps.map((step) => (
          <button
            key={`add-${step}`}
            onClick={() => onAdjust(step)}
            className="px-2 py-1 bg-slate-800 hover:bg-slate-700 rounded text-xs"
          >
            +{step}
          </button>
        ))}
        {steps.map((step) => (
          <button
            key={`sub-${step}`}
            onClick={() => onAdjust(-step)}
            className="px-2 py-1 bg-slate-800 hover:bg-slate-700 rounded text-xs"
          >
            -{step}
          </button>
        ))}
      </div>
    </div>
  );
}

function SimpleField({
  label,
  value,
  onSet,
}: {
  label: string;
  value: number | string;
  onSet: (val: number) => void;
}) {
  const [local, setLocal] = useState(value.toString());

  useEffect(() => {
    setLocal(value.toString());
  }, [value]);

  return (
    <div className="mb-3">
      <div className="text-sm text-white mb-1">{label}</div>
      <div className="flex gap-2">
        <input
          value={local}
          onChange={(e) => setLocal(e.target.value)}
          className="w-24 px-2 py-1 rounded bg-slate-800 border border-slate-700 text-sm text-white"
          inputMode="numeric"
        />
        <button
          onClick={() => {
            const parsed = Number(local);
            if (!Number.isNaN(parsed)) {
              onSet(parsed);
            }
          }}
          className="px-3 py-1 bg-slate-800 hover:bg-slate-700 rounded text-xs"
        >
          Set
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/devtools/OrbDebug.tsx">
import PlaceholderTool from './PlaceholderTool';

export default function OrbDebug() {
  return <PlaceholderTool name="OrbDebug" hint="Use ?devTool=orbdebug for physics readouts." />;
}
</file>

<file path="src/devtools/PlaceholderTool.tsx">
type Props = {
  name: string;
  hint?: string;
};

export default function PlaceholderTool({ name, hint }: Props) {
  return (
    <div className="min-h-screen flex items-center justify-center bg-slate-950 text-slate-100">
      <div className="text-center space-y-3">
        <div className="text-xs text-slate-500 uppercase tracking-wide">Dev Tool</div>
        <div className="text-3xl font-bold text-cyan-300">{name}</div>
        <div className="text-sm text-slate-400 max-w-md mx-auto px-6">
          Scaffold ready. Wire the detailed UI and logic when you are ready to iterate on {name}.
        </div>
        {hint && <div className="text-xs text-slate-500">{hint}</div>}
      </div>
    </div>
  );
}
</file>

<file path="src/devtools/PrestigeSim.tsx">
import PlaceholderTool from './PlaceholderTool';

export default function PrestigeSim() {
  return <PlaceholderTool name="PrestigeSim" hint="Use ?devTool=prestige to model pacing." />;
}
</file>

<file path="src/devtools/ShaderLab.tsx">
import { useEffect, useMemo, useRef, useState } from 'react';
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { createOrbMaterial } from '../orb/orbMaterial';
import { CALM_IDLE_PRESET } from '../orb/orbPresets';

type ControlState = {
  color1: string;
  color2: string;
  chargeColor: string;
  charge: number;
  wobbleIntensity: number;
  patternScale: number;
  fresnelIntensity: number;
  particleCount: number;
  bloomStrength: number;
  bloomThreshold: number;
};

const PRESETS: Record<string, Partial<ControlState>> = {
  calm: {
    color1: CALM_IDLE_PRESET.uniforms.color1,
    color2: CALM_IDLE_PRESET.uniforms.color2,
    chargeColor: CALM_IDLE_PRESET.uniforms.chargeColor,
    charge: CALM_IDLE_PRESET.uniforms.chargeLevel,
    wobbleIntensity: CALM_IDLE_PRESET.uniforms.wobbleIntensity,
    patternScale: CALM_IDLE_PRESET.uniforms.patternScale,
    fresnelIntensity: CALM_IDLE_PRESET.uniforms.fresnelIntensity,
    particleCount: CALM_IDLE_PRESET.particles,
    bloomStrength: CALM_IDLE_PRESET.bloom.strength,
    bloomThreshold: CALM_IDLE_PRESET.bloom.threshold,
  },
  overcharged: {
    color1: '#8b5cf6',
    color2: '#ec4899',
    chargeColor: '#f97316',
    charge: 1,
    wobbleIntensity: 1.8,
    patternScale: 3.6,
    fresnelIntensity: 1.4,
    particleCount: 220,
    bloomStrength: 1.8,
    bloomThreshold: 0.3,
  },
  critical: {
    color1: '#0f172a',
    color2: '#38bdf8',
    chargeColor: '#f43f5e',
    charge: 0.8,
    wobbleIntensity: 1.4,
    patternScale: 4.2,
    fresnelIntensity: 2.1,
    particleCount: 180,
    bloomStrength: 1.3,
    bloomThreshold: 0.2,
  },
};

const DEFAULT_CONTROLS: ControlState = {
  color1: CALM_IDLE_PRESET.uniforms.color1,
  color2: CALM_IDLE_PRESET.uniforms.color2,
  chargeColor: CALM_IDLE_PRESET.uniforms.chargeColor,
  charge: CALM_IDLE_PRESET.uniforms.chargeLevel,
  wobbleIntensity: CALM_IDLE_PRESET.uniforms.wobbleIntensity,
  patternScale: CALM_IDLE_PRESET.uniforms.patternScale,
  fresnelIntensity: CALM_IDLE_PRESET.uniforms.fresnelIntensity,
  particleCount: CALM_IDLE_PRESET.particles,
  bloomStrength: CALM_IDLE_PRESET.bloom.strength,
  bloomThreshold: CALM_IDLE_PRESET.bloom.threshold,
};

export default function ShaderLab() {
  const mountRef = useRef<HTMLDivElement>(null);
  const particlesRef = useRef<THREE.Points | null>(null);
  const particleGeometryRef = useRef<THREE.BufferGeometry | null>(null);
  const stateRef = useRef<ControlState>(DEFAULT_CONTROLS);

  const [controls, setControls] = useState<ControlState>(DEFAULT_CONTROLS);

  stateRef.current = controls;

  const presetOptions = useMemo(
    () => [
      { id: 'calm', label: 'Calm Idle' },
      { id: 'overcharged', label: 'Overcharged' },
      { id: 'critical', label: 'Critical Surge' },
    ],
    []
  );

  useEffect(() => {
    if (!mountRef.current) return;

    const container = mountRef.current;
    const getDimensions = () => {
      const width = container.clientWidth || window.innerWidth;
      const height = container.clientHeight || Math.max(400, window.innerHeight * 0.6);
      return { width, height };
    };
    const { width: initialWidth, height: initialHeight } = getDimensions();
    container.style.minHeight = `${initialHeight}px`;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#05070f');

    const camera = new THREE.PerspectiveCamera(
      60,
      initialWidth / initialHeight,
      0.1,
      100
    );
    camera.position.set(0, 0, 5);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(initialWidth, initialHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
    renderer.domElement.style.width = '100%';
    renderer.domElement.style.height = '100%';
    container.appendChild(renderer.domElement);

    const orbGeometry = new THREE.SphereGeometry(1, 64, 64);
    const orbMaterial = createOrbMaterial({
      color1: controls.color1,
      color2: controls.color2,
      chargeColor: controls.chargeColor,
      chargeLevel: controls.charge,
      wobbleIntensity: controls.wobbleIntensity,
      patternScale: controls.patternScale,
      fresnelIntensity: controls.fresnelIntensity,
    });

    const orb = new THREE.Mesh(orbGeometry, orbMaterial);
    scene.add(orb);

    const light = new THREE.PointLight(controls.chargeColor, 2, 8);
    light.position.set(0, 0, 3);
    scene.add(light);

    const ambient = new THREE.AmbientLight(0xffffff, 0.1);
    scene.add(ambient);

    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(container.clientWidth, container.clientHeight),
      controls.bloomStrength,
      0.8,
      controls.bloomThreshold
    );
    composer.addPass(bloomPass);

    const rebuildParticles = (count: number) => {
      if (particlesRef.current) {
        scene.remove(particlesRef.current);
        particleGeometryRef.current?.dispose();
      }

      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(count * 3);
      const velocities: number[] = [];
      for (let i = 0; i < count; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 2;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 2;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 2;
        velocities.push((Math.random() - 0.5) * 0.02, (Math.random() - 0.5) * 0.02, (Math.random() - 0.5) * 0.02);
      }
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('velocity', new THREE.BufferAttribute(new Float32Array(velocities), 3));

      const material = new THREE.PointsMaterial({
        color: controls.chargeColor,
        size: 0.05,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
      });

      const points = new THREE.Points(geometry, material);
      particlesRef.current = points;
      particleGeometryRef.current = geometry;
      scene.add(points);
    };

    rebuildParticles(controls.particleCount);

    const clock = new THREE.Clock();
    let animationId = 0;

    const animate = () => {
      animationId = requestAnimationFrame(animate);
      const elapsed = clock.getElapsedTime();
      const delta = clock.getDelta();
      const current = stateRef.current!;

      orbMaterial.uniforms.time.value = elapsed;
      orbMaterial.uniforms.chargeLevel.value = current.charge;
      orbMaterial.uniforms.color1.value.set(current.color1);
      orbMaterial.uniforms.color2.value.set(current.color2);
      orbMaterial.uniforms.chargeColor.value.set(current.chargeColor);
      orbMaterial.uniforms.wobbleIntensity.value = current.wobbleIntensity;
      orbMaterial.uniforms.patternScale.value = current.patternScale;
      orbMaterial.uniforms.fresnelIntensity.value = current.fresnelIntensity;

      light.color = new THREE.Color(current.chargeColor);
      light.intensity = 2 + current.charge * 2;

      if (particlesRef.current) {
        const positions = particlesRef.current.geometry.attributes.position as THREE.BufferAttribute;
        const velocities = particlesRef.current.geometry.attributes.velocity as THREE.BufferAttribute;
        for (let i = 0; i < positions.count; i++) {
          const vx = velocities.getX(i);
          const vy = velocities.getY(i);
          const vz = velocities.getZ(i);
          positions.setXYZ(i, positions.getX(i) + vx * (1 + current.charge * 5), positions.getY(i) + vy * (1 + current.charge * 5), positions.getZ(i) + vz * (1 + current.charge * 5));
          const dist = Math.sqrt(
            positions.getX(i) ** 2 + positions.getY(i) ** 2 + positions.getZ(i) ** 2
          );
          if (dist > 2) {
            positions.setXYZ(i, (Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.2);
          }
        }
        positions.needsUpdate = true;
      }

      bloomPass.strength = current.bloomStrength;
      bloomPass.threshold = current.bloomThreshold;

      const heartbeat = 1 + Math.sin(elapsed * 2) * 0.05;
      orb.rotation.y += delta * (0.6 + current.charge * 3);
      orb.rotation.x = Math.sin(elapsed * 0.5) * 0.2;
      orb.scale.setScalar(heartbeat + current.charge * 0.2);
      orb.position.y = Math.sin(elapsed * 1.5) * 0.1;

      composer.render();
    };

    animate();

    const handleResize = () => {
      if (!container) return;
      const { width, height } = getDimensions();
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
      composer.setSize(width, height);
    };
    window.addEventListener('resize', handleResize);

    return () => {
      cancelAnimationFrame(animationId);
      window.removeEventListener('resize', handleResize);
      orbGeometry.dispose();
      orbMaterial.dispose();
      particleGeometryRef.current?.dispose();
      renderer.dispose();
      container.removeChild(renderer.domElement);
    };
  }, []);

  useEffect(() => {
    if (particlesRef.current && particleGeometryRef.current) {
      const material = particlesRef.current.material as THREE.PointsMaterial;
      material.color = new THREE.Color(controls.chargeColor);
    }
  }, [controls.chargeColor]);

  useEffect(() => {
    if (!particlesRef.current || !particleGeometryRef.current || !mountRef.current) return;
    const scene = particlesRef.current.parent;
    if (!scene) return;

    const rebuild = () => {
      const count = controls.particleCount;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(count * 3);
      const velocities: number[] = [];
      for (let i = 0; i < count; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 2;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 2;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 2;
        velocities.push((Math.random() - 0.5) * 0.02, (Math.random() - 0.5) * 0.02, (Math.random() - 0.5) * 0.02);
      }
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('velocity', new THREE.BufferAttribute(new Float32Array(velocities), 3));
      const material = particlesRef.current!.material;
      scene.remove(particlesRef.current!);
      particleGeometryRef.current?.dispose();
      const next = new THREE.Points(geometry, material);
      particlesRef.current = next;
      particleGeometryRef.current = geometry;
      scene.add(next);
    };

    rebuild();
  }, [controls.particleCount]);

  const applyPreset = (id: string) => {
    const preset = PRESETS[id];
    if (!preset) return;
    setControls((c) => ({ ...c, ...preset }));
  };

  const exportConfig = () => {
    const payload = {
      uniforms: {
        color1: controls.color1,
        color2: controls.color2,
        chargeColor: controls.chargeColor,
        chargeLevel: controls.charge,
        wobbleIntensity: controls.wobbleIntensity,
        patternScale: controls.patternScale,
        fresnelIntensity: controls.fresnelIntensity,
      },
      particles: controls.particleCount,
      bloom: {
        strength: controls.bloomStrength,
        threshold: controls.bloomThreshold,
      },
    };
    // eslint-disable-next-line no-console
    console.log('ShaderLab preset', payload);
  };

  const ControlSlider = ({
    label,
    value,
    min,
    max,
    step,
    onChange,
  }: {
    label: string;
    value: number;
    min: number;
    max: number;
    step: number;
    onChange: (n: number) => void;
  }) => (
    <div>
      <div className="flex justify-between text-xs text-slate-400 mb-1">
        <span>{label}</span>
        <span className="text-slate-200">{value.toFixed(2)}</span>
      </div>
      <input
        type="range"
        className="w-full"
        min={min}
        max={max}
        step={step}
        value={value}
        onChange={(e) => onChange(Number(e.target.value))}
      />
    </div>
  );

  return (
    <div className="min-h-screen bg-slate-950 text-slate-100 grid grid-cols-1 lg:grid-cols-[2fr_1fr]">
      <div className="relative">
        <div ref={mountRef} className="w-full h-[60vh] lg:h-screen" />
        <div className="absolute top-4 left-4 bg-black/50 px-3 py-2 rounded text-xs text-slate-300">
          Dev Tool: ShaderLab  use ?devTool=shader
        </div>
      </div>
      <div className="p-6 space-y-4 bg-slate-900/80 border-l border-slate-800 overflow-y-auto">
        <div className="flex items-center justify-between">
          <div>
            <div className="text-xs text-slate-500 uppercase">Presets</div>
            <div className="text-lg font-semibold">Orb Shader Playground</div>
          </div>
          <select
            className="bg-slate-800 border border-slate-700 rounded px-2 py-1 text-sm"
            defaultValue=""
            onChange={(e) => {
              if (e.target.value) applyPreset(e.target.value);
            }}
          >
            <option value="">Choose</option>
            {presetOptions.map((p) => (
              <option key={p.id} value={p.id}>
                {p.label}
              </option>
            ))}
          </select>
        </div>

        <div className="grid grid-cols-2 gap-3">
          <ColorInput
            label="Color 1"
            value={controls.color1}
            onChange={(color) => setControls((c) => ({ ...c, color1: color }))}
          />
          <ColorInput
            label="Color 2"
            value={controls.color2}
            onChange={(color) => setControls((c) => ({ ...c, color2: color }))}
          />
          <ColorInput
            label="Charge Color"
            value={controls.chargeColor}
            onChange={(color) => setControls((c) => ({ ...c, chargeColor: color }))}
          />
        </div>

        <ControlSlider
          label="Charge Level"
          value={controls.charge}
          min={0}
          max={1}
          step={0.01}
          onChange={(n) => setControls((c) => ({ ...c, charge: n }))}
        />
        <ControlSlider
          label="Wobble Intensity"
          value={controls.wobbleIntensity}
          min={0}
          max={3}
          step={0.05}
          onChange={(n) => setControls((c) => ({ ...c, wobbleIntensity: n }))}
        />
        <ControlSlider
          label="Pattern Scale"
          value={controls.patternScale}
          min={0.5}
          max={6}
          step={0.05}
          onChange={(n) => setControls((c) => ({ ...c, patternScale: n }))}
        />
        <ControlSlider
          label="Fresnel Intensity"
          value={controls.fresnelIntensity}
          min={0}
          max={3}
          step={0.05}
          onChange={(n) => setControls((c) => ({ ...c, fresnelIntensity: n }))}
        />
        <ControlSlider
          label="Particle Count"
          value={controls.particleCount}
          min={20}
          max={400}
          step={10}
          onChange={(n) => setControls((c) => ({ ...c, particleCount: Math.floor(n) }))}
        />
        <ControlSlider
          label="Bloom Strength"
          value={controls.bloomStrength}
          min={0}
          max={2.5}
          step={0.05}
          onChange={(n) => setControls((c) => ({ ...c, bloomStrength: n }))}
        />
        <ControlSlider
          label="Bloom Threshold"
          value={controls.bloomThreshold}
          min={0}
          max={1}
          step={0.01}
          onChange={(n) => setControls((c) => ({ ...c, bloomThreshold: n }))}
        />

        <button
          onClick={exportConfig}
          className="w-full py-2 rounded bg-cyan-700 hover:bg-cyan-600 text-sm font-semibold"
        >
          Export Preset to Console
        </button>
      </div>
    </div>
  );
}

function ColorInput({
  label,
  value,
  onChange,
}: {
  label: string;
  value: string;
  onChange: (val: string) => void;
}) {
  return (
    <label className="text-xs text-slate-300 space-y-1">
      <span className="block">{label}</span>
      <input
        type="color"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        className="w-full h-10 rounded border border-slate-700 bg-slate-800"
      />
    </label>
  );
}
</file>

<file path="src/devtools/UpgradeSim.tsx">
import PlaceholderTool from './PlaceholderTool';

export default function UpgradeSim() {
  return <PlaceholderTool name="UpgradeSim" hint="Use ?devTool=upgrade to inspect scaling." />;
}
</file>

<file path="src/index.css">
@import url('https://fonts.googleapis.com/css2?family=Saira:wght@400;500;600;700&display=swap');
@import 'tailwindcss';

:root {
  font-family: 'Saira', 'DM Mono', 'Fira Code', 'Segoe UI', system-ui, -apple-system, sans-serif;
  color: #f8f7ff;
  background: radial-gradient(circle at 20% 20%, #0b1027, #05070f 45%);
}

body {
  margin: 0;
  min-height: 100vh;
  background: #05070f;
  color: #f8f7ff;
}

button {
  font-family: inherit;
}
</file>

<file path="src/main.tsx">
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

const rootElement = document.getElementById('root');

if (!rootElement) {
  throw new Error('Root element #root not found');
}

ReactDOM.createRoot(rootElement).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="src/orb/orbMaterial.ts">
import * as THREE from 'three';
import { CALM_IDLE_PRESET } from './orbPresets';

type ColorInput = THREE.Color | number | string;

export type OrbUniformValues = {
  chargeLevel: number;
  color1: ColorInput;
  color2: ColorInput;
  chargeColor: ColorInput;
  wobbleIntensity: number;
  patternScale: number;
  fresnelIntensity: number;
};

const defaultColors = {
  color1: new THREE.Color(CALM_IDLE_PRESET.uniforms.color1).getHex(),
  color2: new THREE.Color(CALM_IDLE_PRESET.uniforms.color2).getHex(),
  chargeColor: new THREE.Color(CALM_IDLE_PRESET.uniforms.chargeColor).getHex(),
};

const asColor = (value: ColorInput | undefined, fallback: number) => {
  if (value instanceof THREE.Color) return value;
  if (value !== undefined) return new THREE.Color(value);
  return new THREE.Color(fallback);
};

export const DEFAULT_ORB_UNIFORMS: OrbUniformValues = {
  chargeLevel: CALM_IDLE_PRESET.uniforms.chargeLevel,
  color1: asColor(undefined, defaultColors.color1),
  color2: asColor(undefined, defaultColors.color2),
  chargeColor: asColor(undefined, defaultColors.chargeColor),
  wobbleIntensity: CALM_IDLE_PRESET.uniforms.wobbleIntensity,
  patternScale: CALM_IDLE_PRESET.uniforms.patternScale,
  fresnelIntensity: CALM_IDLE_PRESET.uniforms.fresnelIntensity,
};

export function createOrbMaterial(initial?: Partial<OrbUniformValues>): THREE.ShaderMaterial {
  const uniforms: Record<keyof OrbUniformValues | 'time', { value: any }> = {
    time: { value: 0 },
    chargeLevel: { value: initial?.chargeLevel ?? DEFAULT_ORB_UNIFORMS.chargeLevel },
    color1: { value: asColor(initial?.color1, defaultColors.color1) },
    color2: { value: asColor(initial?.color2, defaultColors.color2) },
    chargeColor: { value: asColor(initial?.chargeColor, defaultColors.chargeColor) },
    wobbleIntensity: { value: initial?.wobbleIntensity ?? DEFAULT_ORB_UNIFORMS.wobbleIntensity },
    patternScale: { value: initial?.patternScale ?? DEFAULT_ORB_UNIFORMS.patternScale },
    fresnelIntensity: { value: initial?.fresnelIntensity ?? DEFAULT_ORB_UNIFORMS.fresnelIntensity },
  };

  return new THREE.ShaderMaterial({
    uniforms,
    vertexShader: `
      varying vec3 vNormal;
      varying vec3 vPosition;
      uniform float time;
      uniform float chargeLevel;
      uniform float wobbleIntensity;
      uniform float patternScale;

      void main() {
        vNormal = normalize(normalMatrix * normal);
        vPosition = position;

        vec3 pos = position;
        float wobble = sin(time * 2.0 + position.y * 3.0) * 0.05 * chargeLevel * wobbleIntensity;
        pos += normal * wobble;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `,
    fragmentShader: `
      uniform float time;
      uniform float chargeLevel;
      uniform vec3 color1;
      uniform vec3 color2;
      uniform vec3 chargeColor;
      uniform float patternScale;
      uniform float fresnelIntensity;
      varying vec3 vNormal;
      varying vec3 vPosition;

      void main() {
        float pattern = sin(vPosition.x * patternScale + time) *
                       cos(vPosition.y * patternScale + time * 0.7) *
                       sin(vPosition.z * patternScale + time * 0.5);

        vec3 baseColor = mix(color1, color2, pattern * 0.5 + 0.5);
        vec3 finalColor = mix(baseColor, chargeColor, chargeLevel * 0.7);

        float fresnel = pow(1.0 - dot(vNormal, vec3(0, 0, 1)), 2.0);
        finalColor += fresnel * chargeColor * chargeLevel * 0.5 * fresnelIntensity;

        float particles = step(0.95, sin(vPosition.x * 20.0 + time * 5.0) *
                                     cos(vPosition.y * 20.0 + time * 3.0));
        finalColor += particles * chargeColor * chargeLevel;

        gl_FragColor = vec4(finalColor, 1.0);
      }
    `,
  });
}
</file>

<file path="src/orb/orbPresets.ts">
export type OrbVisualPreset = {
  uniforms: {
    color1: string;
    color2: string;
    chargeColor: string;
    chargeLevel: number;
    wobbleIntensity: number;
    patternScale: number;
    fresnelIntensity: number;
  };
  particles: number;
  bloom: {
    strength: number;
    threshold: number;
  };
};

export const CALM_IDLE_PRESET: OrbVisualPreset = {
  uniforms: {
    color1: '#3a3a3a',
    color2: '#1b1208',
    chargeColor: '#8fdc3b',
    chargeLevel: 0.05,
    wobbleIntensity: 2.4,
    patternScale: 3.8,
    fresnelIntensity: 2.2,
  },
  particles: 40,
  bloom: {
    strength: 0.25,
    threshold: 0.1,
  },
};
</file>

<file path="src/scraprun/config.ts">
import { ScrapUpgradeId } from '../core/ScrapUnlocks';

export type ScrapRunConfig = {
  innerOrbit: number;
  outerOrbit: number;
  orbitSpeed: number;
  strafeSpeed: number;
  maxStrafe: number;
  debrisSpeed: number;
  spawnDistance: number;
  despawnDistance: number;
  spawnInterval: number;
  curvatureStrength: number;
  goodRatio: number;
};

export const BASE_GAME_CONFIG: ScrapRunConfig = {
  innerOrbit: -2,
  outerOrbit: 1,
  orbitSpeed: 0.08,
  strafeSpeed: 0.1,
  maxStrafe: 3,
  debrisSpeed: 0.15,
  spawnDistance: -40,
  despawnDistance: 8,
  spawnInterval: 1000,
  curvatureStrength: 0.15,
  goodRatio: 0.7,
};

export function applyUpgradesToConfig(
  base: ScrapRunConfig,
  upgrades: Record<ScrapUpgradeId, number>
): ScrapRunConfig {
  const afterburners = upgrades.afterburners ?? 0;
  const timeDilation = upgrades.timeDilation ?? 0;

  return {
    ...base,
    strafeSpeed: base.strafeSpeed + afterburners * 0.04,
    maxStrafe: base.maxStrafe + afterburners * 0.5,
    debrisSpeed: base.debrisSpeed * (1 - timeDilation * 0.12),
    spawnInterval: base.spawnInterval * (1 + timeDilation * 0.15),
  };
}
</file>

<file path="src/scraprun/ScrapRunOverlay.tsx">
import ScrapRunScene from './ScrapRunScene';
import { useGameStore } from '../core/GameState';

export default function ScrapRunOverlay() {
  const endRun = useGameStore((s) => s.endScrapRun);
  const upgrades = useGameStore((s) => s.upgrades);

  const handleGameOver = (score: number, collected: number) => {
    endRun(score, collected);
  };

  return (
    <div className="fixed inset-0 z-50">
      <ScrapRunScene onGameOver={handleGameOver} upgrades={upgrades} />
    </div>
  );
}
</file>

<file path="src/scraprun/ScrapRunScene.tsx">
import { useEffect, useRef, useState } from 'react';
import type { MouseEvent, TouchEvent } from 'react';
import * as THREE from 'three';
import type { ScrapUpgradeId } from '../core/ScrapUnlocks';
import { BASE_GAME_CONFIG, applyUpgradesToConfig, type ScrapRunConfig } from './config';
import { createOrbMaterial } from '../orb/orbMaterial';
import { CALM_IDLE_PRESET } from '../orb/orbPresets';

type Props = {
  onGameOver: (score: number, collected: number) => void;
  upgrades: Record<ScrapUpgradeId, number>;
  config?: ScrapRunConfig;
  showCurvatureDebug?: boolean;
  showHitboxes?: boolean;
  minimalUi?: boolean;
  endless?: boolean;
};

export type ScrapRunDebugState = {
  score: number;
  collected: number;
  shields: number;
  gameOver: boolean;
};

export default function ScrapRunScene({
  onGameOver,
  upgrades,
  config = BASE_GAME_CONFIG,
  showCurvatureDebug = false,
  showHitboxes = false,
  minimalUi = false,
  endless = false,
}: Props) {
  const mountRef = useRef<HTMLDivElement>(null);
  const [isHolding, setIsHolding] = useState(false);
  const [touchStart, setTouchStart] = useState<number | null>(null);
  const [currentTouchX, setCurrentTouchX] = useState<number | null>(null);
  const [gameState, setGameState] = useState({
    score: 0,
    collected: 0,
    gameOver: false,
    shields: upgrades.shieldGenerator ?? 0,
  });

  useEffect(() => {
    if (!mountRef.current || gameState.gameOver) return;

    const container = mountRef.current;
    if (container.firstChild) {
      container.replaceChildren();
    }

    const getSize = () => {
      const rect = container.getBoundingClientRect();
      const width = rect.width || window.innerWidth;
      const height = rect.height || window.innerHeight;
      return { width, height };
    };

    const effectiveConfig = applyUpgradesToConfig(config, upgrades);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x05070f);
    scene.fog = new THREE.Fog(0x05070f, 10, 50);

    const { width, height } = getSize();

    const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
    camera.position.set(0, 0, 10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(1.5, window.devicePixelRatio || 1));
    renderer.shadowMap.enabled = true;
    renderer.domElement.style.pointerEvents = 'none';
    container.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    const pointLight = new THREE.PointLight(0x4a90e2, 0.5);
    pointLight.position.set(0, 2, 8);
    scene.add(pointLight);

    const planetGeometry = new THREE.SphereGeometry(6, 32, 32);
    const planetMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a2e, wireframe: true });
    const planet = new THREE.Mesh(planetGeometry, planetMaterial);
    planet.position.set(0, -8, 0);
    planet.receiveShadow = true;
    scene.add(planet);

    const starsGeometry = new THREE.BufferGeometry();
    const starPositions: number[] = [];
    for (let i = 0; i < 200; i++) {
      starPositions.push(
        (Math.random() - 0.5) * 100,
        (Math.random() - 0.5) * 100,
        (Math.random() - 0.5) * 100 - 50
      );
    }
    starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
    const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);

    const playerGroup = new THREE.Group();
    playerGroup.position.set(0, effectiveConfig.innerOrbit, 5);
    scene.add(playerGroup);

    const orbGeometry = new THREE.SphereGeometry(0.8, 64, 64);
    const orbMaterial = createOrbMaterial({
      ...CALM_IDLE_PRESET.uniforms,
      chargeLevel: 0.6,
    });
    const orbMesh = new THREE.Mesh(orbGeometry, orbMaterial);
    orbMesh.castShadow = true;
    playerGroup.add(orbMesh);

    const collectedJunk: THREE.Mesh[] = [];
    const debrisList: THREE.Mesh[] = [];
    let debrisIdCounter = 0;
    let lastSpawnTime = Date.now();
    const shaderClock = new THREE.Clock();

    let currentGameState = { ...gameState };
    let currentOrbitTarget = effectiveConfig.innerOrbit;
    let currentStrafeTarget = 0;
    let currentIsHolding = false;
    let currentTouchPos: number | null = null;

    const hitboxHelper =
      showHitboxes &&
      new THREE.Mesh(
        new THREE.SphereGeometry(1, 16, 16),
        new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.2 })
      );
    if (hitboxHelper) {
      playerGroup.add(hitboxHelper);
    }

    const animate = () => {
      if (!currentGameState.gameOver || endless) {
        requestAnimationFrame(animate);
      }

      planet.rotation.y += 0.002;
      const elapsed = shaderClock.getElapsedTime();
      orbMaterial.uniforms.time.value = elapsed;
      const visualCharge = Math.min(
        1,
        0.2 + currentGameState.collected * 0.05 + (currentIsHolding ? 0.4 : 0)
      );
      orbMaterial.uniforms.chargeLevel.value = visualCharge;

      const currentY = playerGroup.position.y;
      const newY = THREE.MathUtils.lerp(currentY, currentOrbitTarget, effectiveConfig.orbitSpeed);
      playerGroup.position.y = newY;

      const currentX = playerGroup.position.x;
      const newX = THREE.MathUtils.lerp(currentX, currentStrafeTarget, effectiveConfig.strafeSpeed);
      playerGroup.position.x = newX;

      playerGroup.rotation.y += 0.01;

      const now = Date.now();
      if (now - lastSpawnTime > effectiveConfig.spawnInterval) {
        lastSpawnTime = now;

        const isGood = Math.random() < effectiveConfig.goodRatio;
        const geometry = isGood
          ? new THREE.BoxGeometry(0.4, 0.4, 0.4)
          : new THREE.OctahedronGeometry(0.5, 0);
        const material = new THREE.MeshLambertMaterial({
          color: isGood ? 0x4ade80 : 0xef4444,
        });
        const debris = new THREE.Mesh(geometry, material);

        const startX = (Math.random() - 0.5) * 6;
        const startY = (Math.random() - 0.5) * 4 - 1;

        debris.position.set(startX, startY, effectiveConfig.spawnDistance);
        debris.castShadow = true;
        debris.userData = {
          id: debrisIdCounter++,
          type: isGood ? 'good' : 'bad',
          initialX: startX,
          initialY: startY,
          rotationSpeed: { x: Math.random() * 0.04 - 0.02, y: Math.random() * 0.04 - 0.02 },
        };
        scene.add(debris);

        if (showHitboxes) {
          const helper = new THREE.Mesh(
            new THREE.SphereGeometry(0.4, 12, 12),
            new THREE.MeshBasicMaterial({
              color: isGood ? 0x22c55e : 0xf87171,
              wireframe: true,
              transparent: true,
              opacity: 0.25,
            })
          );
          helper.position.copy(debris.position);
          helper.userData.parentId = debris.userData.id;
          scene.add(helper);
          debris.userData.hitboxHelper = helper;
        }

        if (showCurvatureDebug) {
          const points: THREE.Vector3[] = [];
          const steps = 20;
          for (let step = 0; step <= steps; step++) {
            const t = step / steps;
            const z = effectiveConfig.spawnDistance + t * (effectiveConfig.despawnDistance - effectiveConfig.spawnDistance);
            const progress =
              (z - effectiveConfig.spawnDistance) /
              (effectiveConfig.despawnDistance - effectiveConfig.spawnDistance);
            const curve = Math.sin(progress * Math.PI) * effectiveConfig.curvatureStrength;
            const x = startX + startX * curve * 0.5;
            const y = startY + Math.abs(startX) * curve;
            points.push(new THREE.Vector3(x, y, z));
          }
          const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
          const lineMaterial = new THREE.LineBasicMaterial({
            color: isGood ? 0x22c55e : 0xef4444,
            transparent: true,
            opacity: 0.35,
          });
          const line = new THREE.Line(lineGeometry, lineMaterial);
          scene.add(line);
          debris.userData.curveLine = line;
        }

        debrisList.push(debris);
      }

      const hitboxRadius =
        0.5 + currentGameState.collected * 0.1 + (upgrades.tractorBeam ?? 0) * 0.2;
      const playerPos = playerGroup.position;

      for (let i = debrisList.length - 1; i >= 0; i--) {
        const debris = debrisList[i];

        debris.position.z += effectiveConfig.debrisSpeed;

        const progress =
          (debris.position.z - effectiveConfig.spawnDistance) /
          (effectiveConfig.despawnDistance - effectiveConfig.spawnDistance);
        const curve = Math.sin(progress * Math.PI) * effectiveConfig.curvatureStrength;

        debris.position.x = debris.userData.initialX + debris.userData.initialX * curve * 0.5;
        debris.position.y = debris.userData.initialY + Math.abs(debris.userData.initialX) * curve;

        debris.rotation.x += debris.userData.rotationSpeed.x;
        debris.rotation.y += debris.userData.rotationSpeed.y;

        if (debris.userData.hitboxHelper) {
          debris.userData.hitboxHelper.position.copy(debris.position);
        }

        const distance = debris.position.distanceTo(playerPos);
        if (distance < hitboxRadius + 0.3) {
          scene.remove(debris);
          if (debris.userData.hitboxHelper) {
            scene.remove(debris.userData.hitboxHelper);
            debris.userData.hitboxHelper.geometry.dispose();
            debris.userData.hitboxHelper.material.dispose();
          }
          if (debris.userData.curveLine) {
            scene.remove(debris.userData.curveLine);
            debris.userData.curveLine.geometry.dispose();
            debris.userData.curveLine.material.dispose();
          }
          debrisList.splice(i, 1);

          if (debris.userData.type === 'good') {
            currentGameState.collected++;
            currentGameState.score += 10;
            setGameState({ ...currentGameState });

            const junkPiece = debris.clone();
            const angle = (collectedJunk.length / 20) * Math.PI * 2;
            const radius = 0.8 + Math.floor(collectedJunk.length / 20) * 0.3;
            junkPiece.position.set(
              Math.cos(angle) * radius,
              (Math.random() - 0.5) * 0.5,
              Math.sin(angle) * radius
            );
            junkPiece.scale.set(0.5, 0.5, 0.5);
            playerGroup.add(junkPiece);
            collectedJunk.push(junkPiece);
          } else {
            if (currentGameState.shields > 0) {
              currentGameState.shields -= 1;
              setGameState({ ...currentGameState });
            } else if (currentGameState.collected > 0) {
              const loseCount = Math.min(3, currentGameState.collected);
              currentGameState.collected -= loseCount;

              for (let j = 0; j < loseCount && collectedJunk.length > 0; j++) {
                const junk = collectedJunk.pop();
                if (junk) playerGroup.remove(junk);
              }

              setGameState({ ...currentGameState });
            } else {
              if (!endless) {
                currentGameState.gameOver = true;
                setGameState({ ...currentGameState });
              }
            }
          }
          continue;
        }

        if (debris.position.z > effectiveConfig.despawnDistance) {
          scene.remove(debris);
          if (debris.userData.hitboxHelper) {
            scene.remove(debris.userData.hitboxHelper);
            debris.userData.hitboxHelper.geometry.dispose();
            debris.userData.hitboxHelper.material.dispose();
          }
          if (debris.userData.curveLine) {
            scene.remove(debris.userData.curveLine);
            debris.userData.curveLine.geometry.dispose();
            debris.userData.curveLine.material.dispose();
          }
          debrisList.splice(i, 1);
        }
      }

      if (hitboxHelper) {
        hitboxHelper.scale.setScalar(hitboxRadius);
      }

      renderer.render(scene, camera);
    };

    animate();

    const handleResize = () => {
      const { width: nextWidth, height: nextHeight } = getSize();
      camera.aspect = nextWidth / nextHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(nextWidth, nextHeight);
    };
    window.addEventListener('resize', handleResize);

    const stateInterval = setInterval(() => {
      currentOrbitTarget = currentIsHolding ? effectiveConfig.outerOrbit : effectiveConfig.innerOrbit;

      const rect = mountRef.current?.getBoundingClientRect();
      const containerWidth = rect?.width ?? window.innerWidth;
      if (currentTouchPos !== null && containerWidth > 0) {
        const normalizedX = (currentTouchPos - containerWidth / 2) / (containerWidth / 2);
        currentStrafeTarget = normalizedX * effectiveConfig.maxStrafe;
      } else {
        currentStrafeTarget = 0;
      }
    }, 16);

    (window as unknown as Record<string, (value: any) => void>).updateHoldingState = (
      holding: boolean
    ) => {
      currentIsHolding = holding;
    };

    (window as unknown as Record<string, (value: any) => void>).updateTouchPosition = (
      x: number | null
    ) => {
      currentTouchPos = x;
    };

    return () => {
      window.removeEventListener('resize', handleResize);
      clearInterval(stateInterval);

      debrisList.forEach((debris) => {
        if (debris.userData.hitboxHelper) {
          scene.remove(debris.userData.hitboxHelper);
          debris.userData.hitboxHelper.geometry.dispose();
          debris.userData.hitboxHelper.material.dispose();
        }
        if (debris.userData.curveLine) {
          scene.remove(debris.userData.curveLine);
          debris.userData.curveLine.geometry.dispose();
          debris.userData.curveLine.material.dispose();
        }
        scene.remove(debris);
      });

      if (hitboxHelper) {
        playerGroup.remove(hitboxHelper);
        hitboxHelper.geometry.dispose();
        hitboxHelper.material.dispose();
      }

      if (mountRef.current && renderer.domElement && renderer.domElement.parentElement === mountRef.current) {
        mountRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
    };
  }, [gameState.gameOver, upgrades, config, showCurvatureDebug, showHitboxes, endless]);

  useEffect(() => {
    const updater = (window as unknown as Record<string, (value: any) => void>).updateHoldingState;
    if (updater) updater(isHolding);
  }, [isHolding]);

  useEffect(() => {
    const updater = (window as unknown as Record<string, (value: any) => void>).updateTouchPosition;
    if (updater) updater(currentTouchX);
  }, [currentTouchX]);

  useEffect(() => {
    if (gameState.gameOver) {
      onGameOver(gameState.score, gameState.collected);
    }
  }, [gameState.gameOver, gameState.score, gameState.collected, onGameOver]);

  const handleAbort = () => {
    onGameOver(gameState.score, gameState.collected);
  };

  const getRelativeX = (clientX: number) => {
    const rect = mountRef.current?.getBoundingClientRect();
    if (!rect) return null;
    return clientX - rect.left;
  };

  const handleTouchStart = (e: TouchEvent) => {
    setIsHolding(true);
    const touch = e.touches[0];
    const relative = getRelativeX(touch.clientX);
    if (relative === null) return;
    setTouchStart(relative);
    setCurrentTouchX(relative);
  };

  const handleTouchMove = (e: TouchEvent) => {
    if (touchStart !== null) {
      const touch = e.touches[0];
      const relative = getRelativeX(touch.clientX);
      if (relative !== null) {
        setCurrentTouchX(relative);
      }
    }
  };

  const handleTouchEnd = () => {
    setIsHolding(false);
    setTouchStart(null);
    setCurrentTouchX(null);
  };

  const handleMouseDown = (e: MouseEvent) => {
    setIsHolding(true);
    const relative = getRelativeX(e.clientX);
    if (relative === null) return;
    setTouchStart(relative);
    setCurrentTouchX(relative);
  };

  const handleMouseMove = (e: MouseEvent) => {
    if (touchStart !== null && isHolding) {
      const relative = getRelativeX(e.clientX);
      if (relative !== null) {
        setCurrentTouchX(relative);
      }
    }
  };

  const handleMouseUp = () => {
    setIsHolding(false);
    setTouchStart(null);
    setCurrentTouchX(null);
  };

  return (
    <div className="fixed inset-0 bg-black">
      {!minimalUi && (
        <div className="pointer-events-none absolute inset-0 flex flex-col z-10">
          <div className="pointer-events-auto px-4 pt-4 flex items-start justify-between text-xs text-slate-200">
            <div>
              <div className="uppercase tracking-[0.2em] text-lime-300">Trash Run</div>
              <div className="text-[11px] text-slate-400">
                Guide the trashball through the junk tunnel.
              </div>
            </div>
            <div className="text-right">
              <div className="text-sm font-mono text-lime-200">{gameState.score} kJ</div>
              <div className="text-[11px] text-slate-400">Trash hauled: {gameState.collected}</div>
              {gameState.shields > 0 && (
                <div className="text-[11px] text-cyan-300 mt-1">Shields: {gameState.shields}</div>
              )}
            </div>
          </div>

          {!gameState.gameOver && gameState.score === 0 && (
            <div className="pointer-events-none flex-1 flex items-center justify-center px-4">
              <div className="bg-black/75 border border-slate-800 rounded-2xl px-4 py-3 text-center text-sm text-slate-200 max-w-md">
                <div className="text-lime-300 font-semibold mb-1">Charge then dive</div>
                <div>Hold to push into the outer lane, release to fall back in.</div>
                <div className="mt-1">Drag left/right to dodge and scoop trash.</div>
                <div className="mt-1 text-red-300">Red junk cracks the shell.</div>
              </div>
            </div>
          )}

          {!gameState.gameOver && (
            <div className="pointer-events-auto p-4">
              <div className="rounded-2xl border border-slate-800 bg-black/70 backdrop-blur-md p-3 flex items-center justify-between text-xs text-slate-200">
                <div>
                  <div className="uppercase tracking-[0.2em] text-lime-300 text-[11px]">Trash hauled</div>
                  <div className="text-base font-mono text-lime-200">{gameState.collected}</div>
                </div>
                <div className="text-right">
                  <div className="text-[11px] text-slate-400">Shields</div>
                  <div className="text-sm text-cyan-300">{gameState.shields}</div>
                </div>
              </div>
              <button
                onClick={handleAbort}
                className="mt-3 w-full py-3 rounded-xl bg-rose-500 text-black font-semibold text-sm shadow-[0_10px_30px_rgba(244,63,94,0.35)] active:scale-[0.99]"
              >
                Emergency Eject (Keep Trash)
              </button>
            </div>
          )}

          {gameState.gameOver && (
            <div className="pointer-events-auto flex-1 flex items-center justify-center px-4 pb-6">
              <div className="w-full max-w-sm rounded-3xl bg-black/80 border border-rose-500/60 shadow-2xl shadow-rose-900/40 p-6 text-center text-slate-100">
                <div className="text-2xl font-bold text-rose-300 mb-2">Hull Breach</div>
                <div className="text-sm text-slate-300">Burn Output: {gameState.score} kJ</div>
                <div className="text-sm text-lime-300 mt-1">Trash Hauled: {gameState.collected}</div>
                <button
                  onClick={handleAbort}
                  className="mt-4 w-full py-3 rounded-xl bg-lime-400 text-black font-semibold active:scale-[0.99]"
                >
                  Return to Yard
                </button>
              </div>
            </div>
          )}
        </div>
      )}

      <div ref={mountRef} className="w-full h-full pointer-events-none" />

      <div
        className="absolute inset-0 z-0"
        style={{ touchAction: 'none' }}
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        onTouchEnd={handleTouchEnd}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
      />
    </div>
  );
}
</file>

<file path="src/types.d.ts">
declare const __DEV_TOOLS__: boolean;
</file>

<file path="src/ui/MainMenu.tsx">
import { useEffect, useMemo, useState } from 'react';
import { useGameStore } from '../core/GameState';

const BASE_COOLDOWN_MS = 2 * 60 * 1000; // 2 minutes for MVP loop

export default function MainMenu() {
  const {
    energy,
    scrap,
    charge,
    lastRunTime,
    bestRunScore,
    prestigeLevel,
    cosmicEssence,
    upgrades,
    startScrapRun,
    prestige,
  } = useGameStore();

  const cooldownReduction = (upgrades.warpCooldown ?? 0) * 2 * 60 * 1000;
  const effectiveCooldown = useMemo(
    () => Math.max(30_000, BASE_COOLDOWN_MS - cooldownReduction),
    [cooldownReduction]
  );

  const [cooldownRemaining, setCooldownRemaining] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      const remaining = Math.max(0, effectiveCooldown - (Date.now() - lastRunTime));
      setCooldownRemaining(remaining);
    }, 100);

    return () => clearInterval(interval);
  }, [lastRunTime, effectiveCooldown]);

  const canLaunch = cooldownRemaining === 0;
  const canPrestige = energy >= 10000;

  const formatTime = (ms: number) => {
    const mins = Math.floor(ms / 60000);
    const secs = Math.floor((ms % 60000) / 1000);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <div className="pointer-events-none absolute inset-0 flex flex-col justify-end p-4 sm:p-6">
      <div className="pointer-events-auto w-full max-w-3xl mx-auto space-y-3 sm:space-y-4">
        <div className="rounded-3xl border border-lime-500/25 bg-black/70 backdrop-blur-lg shadow-2xl shadow-lime-900/30 p-4 sm:p-5">
          <div className="flex items-start justify-between gap-4">
            <div>
              <div className="text-xs uppercase tracking-[0.2em] text-lime-300">Trashball Energy Yard</div>
              <div className="text-[11px] text-slate-400 mt-1">
                Hold to overcharge the trashball. Release to launch and harvest junk from the belt.
              </div>
            </div>
            <div className="text-right">
              <div className="text-[11px] text-slate-400 uppercase tracking-wide">Burn Output</div>
              <div className="text-3xl sm:text-4xl font-bold text-lime-200 font-mono">
                {Math.floor(energy)}
              </div>
              <div className="text-xs text-slate-400 mt-1">{(charge * 100).toFixed(0)}% charged</div>
            </div>
          </div>

          <div className="mt-3 h-2 rounded-full bg-slate-900 overflow-hidden border border-slate-800">
            <div
              className="h-full bg-gradient-to-r from-lime-400 to-emerald-400 transition-all duration-150"
              style={{ width: `${Math.min(100, charge * 100)}%` }}
            />
          </div>

          <div className="mt-3 flex flex-wrap items-center gap-3 text-xs text-slate-300">
            <span className="px-2 py-1 rounded-full bg-lime-500/10 text-lime-300 font-mono">
              Trash Hauled: {Math.floor(scrap)}
            </span>
            <span className="px-2 py-1 rounded-full bg-slate-800 text-slate-200">
              Best Burn Output: {bestRunScore}
            </span>
            <span className="px-2 py-1 rounded-full bg-amber-500/10 text-amber-300">
              Prestige {prestigeLevel} | Essence {cosmicEssence}
            </span>
          </div>
        </div>

        <div className="rounded-3xl border border-slate-800 bg-black/70 backdrop-blur-lg shadow-xl p-4 sm:p-5">
          <div className="grid grid-cols-1 sm:grid-cols-[1.6fr_1fr] gap-3 sm:gap-4 items-stretch">
            <button
              onClick={startScrapRun}
              disabled={!canLaunch}
              className={`w-full py-4 sm:py-5 rounded-2xl text-lg font-semibold tracking-wide transition-all active:scale-[0.99] ${
                canLaunch
                  ? 'bg-gradient-to-r from-lime-400 to-emerald-500 text-black shadow-[0_10px_40px_rgba(74,222,128,0.35)]'
                  : 'bg-slate-900 text-slate-600 border border-slate-800 cursor-not-allowed'
              }`}
            >
              {canLaunch ? 'Start Trash Run' : `Cooldown ${formatTime(cooldownRemaining)}`}
            </button>

            <div className="flex flex-col gap-2 text-sm text-slate-200">
              <button
                onClick={prestige}
                disabled={!canPrestige}
                className={`w-full py-3 rounded-xl font-semibold transition-all active:scale-[0.99] ${
                  canPrestige
                    ? 'bg-gradient-to-r from-amber-400 to-orange-500 text-black shadow-[0_10px_30px_rgba(251,191,36,0.35)]'
                    : 'bg-slate-900 text-slate-500 border border-slate-800 cursor-not-allowed'
                }`}
              >
                Ignite Prestige Core
              </button>
              <div className="rounded-xl border border-slate-800 bg-slate-900/70 px-3 py-2 text-xs leading-relaxed text-slate-300">
                {canPrestige
                  ? `Ready to mint +${Math.floor(Math.sqrt(energy / 10000))} essence from stored burn output.`
                  : 'Bank 10,000+ burn output to distill new essence.'}
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/ui/UpgradePanel.tsx">
import { useEffect, useState } from 'react';
import { SCRAP_UPGRADE_CATEGORIES, getUpgradeCost } from '../core/ScrapUnlocks';
import { useGameStore } from '../core/GameState';

export default function UpgradePanel() {
  const { scrap, upgrades, purchaseUpgrade } = useGameStore();
  const [expanded, setExpanded] = useState(() => typeof window !== 'undefined' && window.innerWidth >= 640);
  const [activeCategory, setActiveCategory] = useState(SCRAP_UPGRADE_CATEGORIES[0].id);

  useEffect(() => {
    const handleResize = () => {
      if (window.innerWidth < 640) {
        setExpanded(false);
      }
    };
    handleResize();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return (
    <div className="pointer-events-none absolute inset-0 flex flex-col justify-end items-end p-4 sm:p-6">
      <div className="pointer-events-auto w-full sm:w-96 max-w-lg">
        <div className="rounded-3xl bg-black/75 border border-slate-800 shadow-xl backdrop-blur-lg overflow-hidden">
          <div className="flex items-center justify-between px-4 py-3 border-b border-slate-800">
            <div>
              <div className="text-xs uppercase tracking-[0.25em] text-amber-300">Upgrades</div>
              <div className="text-[11px] text-slate-400">
                Compactors, scavengers, and landfill tricks to squeeze more junk.
              </div>
            </div>
            <button
              onClick={() => setExpanded((v) => !v)}
              className="ml-3 rounded-full bg-slate-900 px-3 py-2 text-xs font-semibold text-slate-200 border border-slate-700 hover:border-amber-400 transition-all"
            >
              {expanded ? 'Hide' : 'Show'}
            </button>
          </div>

          {expanded && (
            <div className="p-4 space-y-3">
              <div className="flex flex-wrap gap-2">
                {SCRAP_UPGRADE_CATEGORIES.map((category) => (
                  <button
                    key={category.id}
                    onClick={() => setActiveCategory(category.id)}
                    className={`px-3 py-2 rounded-xl text-xs font-semibold border transition-all ${
                      activeCategory === category.id
                        ? 'bg-amber-500/15 border-amber-400 text-amber-100 shadow-[0_4px_20px_rgba(251,191,36,0.25)]'
                        : 'bg-slate-900 border-slate-800 text-slate-300 hover:border-slate-600'
                    }`}
                  >
                    {category.label}
                  </button>
                ))}
              </div>

              <div className="text-sm font-mono text-amber-200">
                Trash stash: {Math.floor(scrap)}
              </div>

              <div className="space-y-3 max-h-72 overflow-y-auto pr-1">
                {SCRAP_UPGRADE_CATEGORIES.find((c) => c.id === activeCategory)?.upgrades.map(
                  (upgrade) => {
                    const level = upgrades[upgrade.id] ?? 0;
                    const cost = getUpgradeCost(upgrade.id, level);
                    const maxed = level >= upgrade.max;
                    const canAfford = scrap >= cost;

                    return (
                      <button
                        key={upgrade.id}
                        onClick={() => purchaseUpgrade(upgrade.id)}
                        disabled={!canAfford || maxed}
                        className={`w-full p-3 rounded-2xl border text-left transition-all ${
                          maxed
                            ? 'border-lime-500/70 bg-lime-900/30 text-lime-100'
                            : canAfford
                              ? 'border-amber-400/70 bg-amber-500/10 text-amber-100 hover:border-amber-300 hover:bg-amber-500/15'
                              : 'border-slate-800 bg-slate-900/60 text-slate-400 cursor-not-allowed'
                        }`}
                      >
                        <div className="flex items-start justify-between gap-2">
                          <div>
                            <div className="font-semibold text-sm">{upgrade.label}</div>
                            <div className="text-xs text-slate-300 mt-0.5">{upgrade.desc}</div>
                          </div>
                          <span className="text-xs text-amber-200">
                            {maxed ? 'Maxed' : `Lvl ${level}/${upgrade.max}`}
                          </span>
                        </div>
                        {!maxed && (
                          <div className="mt-2 text-xs text-amber-300 font-mono">Cost: {cost} trash</div>
                        )}
                      </button>
                    );
                  }
                )}
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "composite": true,
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "types": ["vite/client"]
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.d.ts">
declare const _default: import("vite").UserConfig;
export default _default;
</file>

<file path="vite.config.js">
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import tailwindcss from '@tailwindcss/vite';
export default defineConfig({
    plugins: [react(), tailwindcss()],
    define: {
        __DEV_TOOLS__: JSON.stringify(true),
    },
    server: {
        port: 5173,
    },
});
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import tailwindcss from '@tailwindcss/vite';

export default defineConfig({
  plugins: [react(), tailwindcss()],
  define: {
    __DEV_TOOLS__: JSON.stringify(true),
  },
  server: {
    port: 5173,
  },
});
</file>

<file path="README.md">
#  Trashball: Core Accumulator

Hybrid idle/runner game where you grow a cosmic trashball to power yourself up and launch high-stakes salvage runs. Built with React, Three.js, and Zustand.
This is a work-in-progress prototype; expect rough edges, placeholder art, and frequent changes.

##  Concept: The Trashball's Ascent

You control a Core Accumulatora massive orb that generates power by accumulating and compressing cosmic junk.

1.  **Generate Mass:** Charge the orb to generate **Mass** (your primary resource).
2.  **Launch Harvests:** Spend Mass to launch **Debris Harvest** runs (the mini-game).
3.  **Collect Salvage:** During the run, you collect junk (physical objects) which translates to **Salvage** (your upgrade currency).
4.  **Prestige:** When the Trashball reaches critical mass, you can **Prestige** to gain permanent Essence and restart with a stronger Core.

##  Core Gameplay Mechanics

### 1. The Core Accumulator (Idle Loop)

This is the main 3D orb scene where you accumulate power:

* **Charging:** **Hold the screen/mouse button** to charge the Core's energy vortex.
    * Higher **Vortex Power** (charge level) dramatically increases **Mass** generation per tick.
    * Releasing the hold allows the Vortex Power to slowly dampen down.
* **Mass (Energy):** This resource tracks the Trashball's overall size/power. It is spent to launch Debris Harvests and is the requirement for Prestige.
* **Physics:** The orb reacts to holding (Thrust) and releasing (Gravity/Damping) to create a satisfying, skill-based idle loop.

### 2. Debris Harvest (Runner Mini-Game)

The high-stakes mini-game where you earn your currency:

* **Goal:** Navigate the Trashball through space to **Collect green junk** (earn physical mass) and **Avoid red obstacles** (lose mass/shields).
* **Controls:**
    * **Hold:** Moves the Trashball into the **Outer Orbit**.
    * **Release:** Moves the Trashball into the **Inner Orbit**.
    * **Drag/Strafe:** Allows horizontal movement to target junk and dodge obstacles.
* **Rewards:**
    * **Trashball Mass:** The physical junk collected is temporarily attached to the Trashball.
    * **Salvage (Scrap):** The final score and collected mass from the run are converted into permanent Salvage currency.
    * *Tip: Launching the run with high Vortex Power grants a bonus Salvage multiplier!*.

##  Progression and Upgrades

All upgrades are purchased using **Salvage** and are grouped into specialized categories:

### I. Core Density (Harmonic)
*Focuses on Mass/Energy generation.*

| Upgrade | Effect |
| :--- | :--- |
| **Core Compressor** (`resonanceTuner`) | Increases Mass generation rate per level. |
| **Critical Surge** (`criticalSurge`) | Chance to multiply a Mass generation tick when holding. |
| **Vortex Lock** (`orbitalStabilization`) | Reduces charge drain when released (more efficient idle). |

### II. Acquisition (Scavenger)
*Focuses on the Debris Harvest run's efficiency and defense.*

| Upgrade | Effect |
| :--- | :--- |
| **Junk Magnet** (`tractorBeam`) | Wider scrap pickup radius (larger Trashball hitbox). |
| **Shield Generator** (`shieldGenerator`) | Grants shield charges to ignore a hit from an obstacle. |
| **Afterburners** (`afterburners`) | Faster strafe speed in the Debris Harvest run. |

### III. Temporal (Chronos)
*Focuses on mission throughput and run time control.*

| Upgrade | Effect |
| :--- | :--- |
| **Warp Cooldown** (`warpCooldown`) | Reduces the launch cooldown timer for the Debris Harvest. |
| **Gravity Shift** (`timeDilation`) | Debris moves slower during the run, making collection easier. |

##  Technical Structure

* `src/core`: Zustand store (`GameState.ts`) and upgrade definitions (`ScrapUnlocks.ts`).
* `src/orb`: 3D three.js scene for the Core Accumulator/idle loop (`OrbScene.tsx`).
* `src/scraprun`: Full-screen runner mini-game (`ScrapRunScene.tsx`).
* `src/ui`: Interface components (HUD, cooldown, Upgrade Panel).

##  Getting Started

1.  Install dependencies: `npm install`
2.  Start dev server: `npm run dev`
</file>

<file path="src/orb/OrbScene.tsx">
import { useEffect, useRef } from 'react';
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { useGameStore } from '../core/GameState';
import { createOrbMaterial } from './orbMaterial';
import { CALM_IDLE_PRESET } from './orbPresets';

type Props = {
  isHolding: boolean;
};

const CHARGE_COLOR = new THREE.Color(CALM_IDLE_PRESET.uniforms.chargeColor).getHex();

export default function OrbScene({ isHolding }: Props) {
  const mountRef = useRef<HTMLDivElement>(null);
  const addEnergy = useGameStore((s) => s.addEnergy);
  const setCharge = useGameStore((s) => s.setCharge);
  const physics = useGameStore((s) => s.physics);
  const upgrades = useGameStore((s) => s.upgrades);
  const prestigeLevel = useGameStore((s) => s.prestigeLevel);
  const scrap = useGameStore((s) => s.scrap);

  const stateRef = useRef({
    velocity: 0,
    charge: 0,
  });

  // Keep latest external values without recreating the scene.
  const holdRef = useRef(isHolding);
  useEffect(() => {
    holdRef.current = isHolding;
  }, [isHolding]);

  const physicsRef = useRef(physics);
  useEffect(() => {
    physicsRef.current = physics;
  }, [physics]);

  const upgradesRef = useRef(upgrades);
  useEffect(() => {
    upgradesRef.current = upgrades;
  }, [upgrades]);

  const prestigeRef = useRef(prestigeLevel);
  useEffect(() => {
    prestigeRef.current = prestigeLevel;
  }, [prestigeLevel]);

  const scrapUpdaterRef = useRef<((scrapValue: number) => void) | null>(null);
  const scrapGroupRef = useRef<THREE.Group | null>(null);

  useEffect(() => {
    if (!mountRef.current) return;

    const container = mountRef.current;

    const getSize = () => {
      const rect = container.getBoundingClientRect();
      const width = rect.width || window.innerWidth;
      const height = rect.height || window.innerHeight;
      return { width, height };
    };

    const { width, height } = getSize();

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(1.75, window.devicePixelRatio || 1));
    renderer.setClearColor(0x05070f, 1);
    renderer.domElement.style.position = 'absolute';
    renderer.domElement.style.inset = '0';
    container.appendChild(renderer.domElement);

    camera.position.z = 5;

    const orbGeometry = new THREE.SphereGeometry(1, 64, 64);
    const orbMaterial = createOrbMaterial({ chargeColor: CHARGE_COLOR });

    const orb = new THREE.Mesh(orbGeometry, orbMaterial);
    scene.add(orb);

    const scrapGroup = new THREE.Group();
    orb.add(scrapGroup);
    scrapGroupRef.current = scrapGroup;

    const scrapMaterials = [
      new THREE.MeshStandardMaterial({ color: 0x9ca3af, metalness: 0.3, roughness: 0.7 }),
      new THREE.MeshStandardMaterial({ color: 0x4b5563, metalness: 0.4, roughness: 0.8 }),
      new THREE.MeshStandardMaterial({ color: 0x6b7280, metalness: 0.2, roughness: 0.9 }),
      new THREE.MeshStandardMaterial({ color: 0x22c55e, emissive: 0x16a34a, emissiveIntensity: 0.8 }),
    ];
    const scrapGeometries = [
      new THREE.BoxGeometry(0.26, 0.14, 0.08),
      new THREE.CylinderGeometry(0.08, 0.12, 0.26, 6),
      new THREE.TetrahedronGeometry(0.2),
      new THREE.BoxGeometry(0.18, 0.08, 0.26),
    ];

    scrapUpdaterRef.current = (scrapValue: number) => {
      const group = scrapGroupRef.current;
      if (!group) return;

      const maxPiecesBase = 40;
      const screenScale = window.innerWidth < 640 ? 0.6 : 1;
      const maxPieces = Math.floor(maxPiecesBase * screenScale);
      const count = Math.min(maxPieces, Math.max(0, Math.floor(scrapValue)));
      group.clear();

      for (let i = 0; i < count; i++) {
        const geometry = scrapGeometries[i % scrapGeometries.length];
        const material = scrapMaterials[i % scrapMaterials.length];
        const scrapPiece = new THREE.Mesh(geometry, material);
        scrapPiece.castShadow = true;

        const direction = new THREE.Vector3(
          Math.random() - 0.5,
          Math.random() - 0.5,
          Math.random() - 0.5
        ).normalize();
        const radius = 1.05 + Math.random() * 0.35;
        scrapPiece.position.copy(direction.multiplyScalar(radius));
        scrapPiece.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );
        const scale = 0.7 + Math.random() * 0.6;
        scrapPiece.scale.setScalar(scale);

        group.add(scrapPiece);
      }
    };

    scrapUpdaterRef.current(scrap);

    const particleCount = CALM_IDLE_PRESET.particles;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleVelocities: { x: number; y: number; z: number }[] = [];

    for (let i = 0; i < particleCount; i++) {
      particlePositions[i * 3] = (Math.random() - 0.5) * 2;
      particlePositions[i * 3 + 1] = (Math.random() - 0.5) * 2;
      particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 2;
      particleVelocities.push({
        x: (Math.random() - 0.5) * 0.02,
        y: (Math.random() - 0.5) * 0.02,
        z: (Math.random() - 0.5) * 0.02,
      });
    }

    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));

    const particleMaterial = new THREE.PointsMaterial({
      color: CHARGE_COLOR,
      size: 0.05,
      transparent: true,
      opacity: 0,
      blending: THREE.AdditiveBlending,
    });

    const particles = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particles);

    const ambientLight = new THREE.AmbientLight(0x404040, 2);
    scene.add(ambientLight);

    const pointLight = new THREE.PointLight(CHARGE_COLOR, 0, 10);
    pointLight.position.set(0, 0, 3);
    scene.add(pointLight);

    // Post-processing: bloom for high charge glow
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(width, height),
      CALM_IDLE_PRESET.bloom.strength,
      0.8,
      CALM_IDLE_PRESET.bloom.threshold
    );
    composer.addPass(bloomPass);

    const clock = new THREE.Clock();
    let animationId = 0;

    const animate = () => {
      animationId = requestAnimationFrame(animate);
      const deltaTime = clock.getDelta();
      const elapsedTime = clock.getElapsedTime();
      const localState = stateRef.current;

      const physics = physicsRef.current;
      const upgrades = upgradesRef.current;
      const prestigeLevel = prestigeRef.current;

      if (holdRef.current) {
        localState.velocity += physics.thrustForce * deltaTime;
        localState.charge = Math.min(1, localState.charge + deltaTime * 2);
      } else {
        const stabilizationBonus = (upgrades.orbitalStabilization ?? 0) * 0.02;
        const effectiveDamping = Math.max(0.7, physics.chargeDamping - stabilizationBonus);
        localState.velocity -= physics.gravity * deltaTime;
        localState.charge *= effectiveDamping;
      }

      localState.velocity = Math.max(
        -physics.terminalVelocity,
        Math.min(physics.terminalVelocity, localState.velocity)
      );

      setCharge(localState.charge);

      if (localState.charge > 0) {
        const baseGen = localState.charge * 10 * deltaTime;
        const resonanceBonus = 1 + (upgrades.resonanceTuner ?? 0) * 0.15;
        const prestigeBonus = 1 + prestigeLevel * 0.5;
        const surgeChance = Math.min(1, (upgrades.criticalSurge ?? 0) * 0.05);
        const surgeMultiplier = Math.random() < surgeChance ? 10 : 1;
        addEnergy(baseGen * resonanceBonus * prestigeBonus * surgeMultiplier);
      }

      const heartbeat = 1 + Math.sin(elapsedTime * (holdRef.current ? 2 : 1)) * 0.05;
      const rotationSpeed = 0.5 + localState.charge * 3;
      orb.rotation.y = elapsedTime * rotationSpeed;
      orb.rotation.x = Math.sin(elapsedTime * 0.3) * 0.2;
      orb.scale.setScalar(heartbeat + localState.charge * 0.2);

      orbMaterial.uniforms.time.value = elapsedTime;
      orbMaterial.uniforms.chargeLevel.value = localState.charge;
      orb.position.y = Math.sin(elapsedTime * 2) * 0.1 * (1 - localState.charge * 0.5);

      particleMaterial.opacity = localState.charge * 0.8;
      const positions = particleGeometry.attributes.position.array as Float32Array;

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] += particleVelocities[i].x * (1 + localState.charge * 5);
        positions[i * 3 + 1] += particleVelocities[i].y * (1 + localState.charge * 5);
        positions[i * 3 + 2] += particleVelocities[i].z * (1 + localState.charge * 5);

        const dist = Math.sqrt(
          positions[i * 3] ** 2 +
            positions[i * 3 + 1] ** 2 +
            positions[i * 3 + 2] ** 2
        );

        if (dist > 2) {
          positions[i * 3] = (Math.random() - 0.5) * 0.2;
          positions[i * 3 + 1] = (Math.random() - 0.5) * 0.2;
          positions[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
        }
      }

      particleGeometry.attributes.position.needsUpdate = true;
      pointLight.intensity = localState.charge * 5;

      bloomPass.strength = Math.max(CALM_IDLE_PRESET.bloom.strength, localState.charge * 2);
      composer.render();
    };

    animate();

    const handleResize = () => {
      const { width: nextWidth, height: nextHeight } = getSize();
      camera.aspect = nextWidth / nextHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(nextWidth, nextHeight);
      composer.setSize(nextWidth, nextHeight);
    };

    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
      cancelAnimationFrame(animationId);
      if (mountRef.current) {
        mountRef.current.removeChild(renderer.domElement);
      }
      scrapGroup.clear();
      scrapGeometries.forEach((geo) => geo.dispose());
      scrapMaterials.forEach((mat) => mat.dispose());
      orbGeometry.dispose();
      orbMaterial.dispose();
      particleGeometry.dispose();
      particleMaterial.dispose();
      renderer.dispose();
    };
  }, [addEnergy, setCharge]);

  useEffect(() => {
    scrapUpdaterRef.current?.(scrap);
  }, [scrap]);

  return <div ref={mountRef} className="absolute inset-x-0 top-0 bottom-32 sm:bottom-40" />;
}
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist/

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*
repomix-output.xml
</file>

</files>
